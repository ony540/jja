{
    "배열과 메서드 2": [
        "먼저 배열 전체를 순회하며 반복 작업하는 메소드를 짚고 넘어가겠습니다. ",
        "forEach입니다. forEach는 인자로 요소의 각 인덱스, 순회 중인 배열을 순서대로 가져와 주어진 함수를 배열 요소 각각을 대상으로 반복 작업하는 메서드입니다. ",
        "forEach 메서드는 인덱스와 어레이가 필요하지 않다면 생략할 수 있습니다.",
        "forEach를 출력해보면 반복 작업만 할 뿐 어떠한 값을 반환하지 않습니다. ",

        "다음으로 Map입니다. Map은 forEach와 같이 값 인덱스 배열을 인자로 받을 수 있지만, forEach와 달리 반복 작업한 결과를 모아 새로운 배열로 반환합니다.",
        "해당 코드를 보면 각 요소의 랭스, 문자열, 길이를 담은 새로운 배열로 반환하는 것을 볼 수 있습니다. ",
        "다음 예제는 이름과 성, 값을 더해 풀 네임을 가지는 객체를 배열로 반환하는 예제입니다.  ",
        "아이템 각 아이템 각 요소를 대상으로 반복 작업하여 우측처럼 새로운 배열로 반환됩니다. ",
        "forEach는 반환 값 없이 배열 내 요소를 대상으로 반복 작업하고, 맵은 반복 작업한 결과물을 새로운 배열 형태로 반환한다면 reduce는 어떤 작업을 할까요? ",

        "반복 작업하는 것까지 다른 메서드와 같지만 reduce는 배열을 기반으로 누적 연산하여 값 하나를 반환합니다.",
        "accumulator는 이전 함수의 호출의 결과 누적 값을 의미하며, current는 현재 값, index와 array는 인덱스와 순회 중인 배열을 의미하고, initial은 함수 최초 호출 시, 사용되는 초기 값을 의미합니다. ",
        "accumulator와 current를 제외한 세 가지는 옵션 값으로 생략이 가능합니다.",
        "앞서 말한 것처럼 주어진 함수를 배열 요소 각각을 대상으로 반복 작업 실행문을 통해 한 값에 누적시켜 값 하나를 반환합니다. 해당 예제는 누적합을 구하는 예제로 표와 같이 배열을 순환하며 반복하는 것을 확인할 수 있습니다. ",
        "초깃값 생략이 가능하지만 해당 배열이 빈 배열일 경우 오류가 발생할 수 있습니다. ",

        "다음으로 sort입니다. sort는 배열 자체를 변경시키며 요소를 정렬하는데요. 해당 예제의 결과를 보면 15가 맞지 않는 위치에 있는 것을 확인할 수 있습니다. ",
        "이는 문자열로 취급되어 정렬되기 때문인데요. ",
        "따라서 새로운 정렬 기준을 만들려면 어레이 소트에 새로운 함수를 넘겨야 합니다.",
        "예제에 해당 함수가 인자로 넘어가면 마이너스의 a 마이너스 b의 결과가 마이너스 1이면 즉 a가 b보다 작으면 앞으로 정렬되어 우측과 같이 정렬됩니다. ",
        "이를 화살표 함수로 표현하면 이처럼 표현할 수 있으니 간단히 이렇게 기억해 주시면 되겠습니다. ",
        "마지막으로 split은 인자로 받은 구분자를 기준으로 문자열을 쪼개서 배열로 반환하는 메서드입니다. 예제의 콤마를 기준으로 문자열을 배열로 반환합니다. ",
        "join은 스플릿과 반대로 인자로 받은 요소를 기준으로 배열의 요소를 합쳐서 문자열로 반환합니다. "
    ],
    "반복문과 switch문": [
        "예제와 함께 알아보고 각각 기억해야할 점을 짚고넘어가는 방식으로 발표하겠습니다. 반복문은 동일한 코드를 여러 번 반복해야할 때 사용하고, 조건(condition)이 참이면 본문의 코드가 실행됩니다.",

        "먼저 와일 문입니다. 조건이 falsy해지기 전까지 반복문 본문이 실행됩니다. 따라서 이 예제에서는 3,2,1이 경고창으로 뜨고 0이 되면 반복문을 탈출합니다.",
        "조건엔 비교뿐만 아니라 모든 종류의 표현식, 변수 사용가능하며 ",
        "반복문 본문이 한 번 실행되는 것을 반복(iteration, 이터레이션)이라고 부르며,  이 예시에선 반복문이 세 번의 이터레이션을 만듭니다.",
        "do while문을 사용하면 본문이 먼저 실행되고, 조건을 확인한 후 조건이 truthy인 동안엔 본문이 계속 실행됩니다. 조건에 상관없이, 본문을 최소한 한 번이라도 실행하고 싶을 때만 사용합니다.",
        "다음으로 포문입니다. 포문의 구성요소에는 비긴,컨디션,바디,스탭에 있습니다. begin은 진입할 때 단 한 번 실행되는 초기값이며 ",
        "condition은 매 반복마다 해당 조건이 확인하고, 조건이 truthy일 동안 body의 영역이 실행됩니다. ",
        "step은 각 반복의 body가 실행된 이후에 실행됩니다. 따라서 이 예제는 0 1 2가 출력되고 끝으로 i가 3이되면 컨디션이 맞지않게 되며 반복문을 탈출합니다.",
        "또 변수 i를 반복문 안에서 선언하였는데, 이런 방식을 ‘인라인’ 변수 선언이라고 부릅니다. 이렇게 선언한 변수는 반복문 안에서만 접근할 수 있기때문에 for문 밖에서 i를 사용하려고 해도 정의되지않았다는 오류가 발생합니다. ",
        "반복문에서 기억해야할 것이 있다면 반복문 본문이 한 번 실행되는 것을 이터레이션이라고 부른다는 것입니다. 조건에 상관없이, 본문을 최소한 한 번이라도 실행하고 싶을 때 do while문을 사용한다는 것이 있습니다. ",
        "다음으로 break / continue 입니다. 대개 반복문의 조건이 falsy가 되면 반복문이 종료되는데요, 그런데 특별한 지시자인 break를 사용하면 언제든 원하는 때에 반복문을 빠져나올 수 있습니다. 예시의 반복문은 사용자가 벨류에 아무런 값도 입력하지 않으면 반복문을 '종료’합니다 ",
        "컨티뉴의 경우 break의 가벼운 버전으로  break는 전체 반복문을 멈추지만, continue의 경우 현재 실행 중인 이터레이션을 멈추고 다음 반복으로 넘어갑니다. 예제의 경우 짝수일 경우 alert를 실행하지않고 다음 스탭으로 넘어가죠. ",
        "여기서 짚고 넘어갈 점은 표현식이 아닌 삼항연산자를 쓸때는  break나 continue가 올 수 없으니 사용하면 안된다는 것을 기억하면 되겠습니다. ",
        "반복문을 사용하다보면 중첩해서 사용하는 경우가 있는데, 이때는 어떻게 한번에 반복문을 탈출할 수 있을까요? 예제와 같이 반복문 앞에 레이블이름을 지정하여 붙이면 break,continue와 함께 이를 사용할 수 있습니다.해당 예제는 중첩된 포문안에서 인풋에 값이없으면 outer라는 바깥의 포문을 break, 종료하게 됩니다. ",
        "이 예제는 1과 그 수 자신 이외의 자연수로는 나눌 수 없는 자연수인 소수를 찾는 예제인데요, 내부 포문에서 변수 J에 해당하는 제수로 나누어떨어질 경우, 이미 소수가 아니기 때문에 더이상 제수가 있는지 확인할 필요가 없기때문에 해당 반복을 멈추고, nextPrime이라는 바깥 포문의 다음 이터레이션이 실행되도록합니다. ",
        "여기서는 break와 continue를 통해 반복문의 조건이 참이더라도 반복문을 탈출할 수 있다는 것과. 반복문 앞에 레이블을 이용해 여러 개의 중첩 반복문을 한 번에 빠져나올 수 있다는 것을 기억하고 넘어가면 좋을 것같습니다. ",
        "마지막으로 스위치문입니다. 가독성을 높은 조건문이라고 말할 수 있습니다. ",
        "기본적 형태를 보자면 case문에서 변수 a의 값과 일치하는 값을 찾으면 해당 case 문의 아래의 코드가 실행됩니다. 이때, break문을 만나거나 switch 문이 끝나면 코드의 실행은 멈춥니다. 값과 일치하는 case문이 없다면, default문 아래의 코드가 t실행되고, break문이 없는 경우엔 조건에 상관없이 다음 case문이 실행되기 때문에 주의해야합니다. ",
        "앞서말한 특성에 따라서 여러개의 case문을 예제에서 볼 수 있듯이 묶어서 같은 코드가 실행되도록할 수 있습니다. ",
        "이 예제에서 prompt에 3을 입력하면 어떤 창이 뜰까요? ",
        "3을 입력하더라도  case 3:에 해당하는 세 번째 alert문은 실행되지 않고 defult에 해당하는 알 수 없는 값을 입력하셨습니다.는 창이 뜨게됩니다. prompt함수는 값을 문자열로 변환해 반환하고, 3과  문자열‘3’은 다르기 때문입니다. ",
        "끝으로 스위치문은 가독성을 높인 조건문이며, break와 실행될 코드를 작성하지 않음으로 여러 case문을 묶을 수 있고, case문의 인수에서 자료형을 구분한다. 라는 것을 기억해주시길 바랍니다. "
    ],
    "this": [
        "코어 자바스크립트 튜토리얼에 멋쟁이 사자처럼의 교안,책 코어자바스크립트를 함께 참고하여 구성했으며 예제와 함께 알아보는 방식으로 발표하겠습니다. this는 자신을 호출한 객체 , 자신을 생성할 객체라고 정의할 수 있으며, \"this는 함수를 호출될 때 결정\"됩니다. ",
        "먼저 전역공간입니다. 전역공간의 this의 경우 브라우저에서는 window로, ",
        "node.js 환경에서는 global출력됩니다 ",
        "엄격모드에서는 undefined이라고 설명되어있어 확인해보니 ",
        "엄격모드에서는 전역공간에서의 this는 window이고, 함수 내부에 this가 있을 때 undefined으로 정의됩니다. 복잡하게 생각할 수 있지만, 이런게 있다는 사실만 알아두고 앞으로는 브라우저 기준으로 설명드리겠습니다. ",
        "두번째로 함수에서의 this입니다. 이 경우에도 전역상태와 동일하게, 함수 내부에 this가 있고 이 함수를 호출하면 window로 정의를 합니다. 설계상의 오류라고 하며, 일단은 함수는 window라고 기억하고 넘어가겠습니다. ",

        "다음으로 메서드입니다. 예제코드를 실행하게 되면 두줄 모두 func1 메서드의 멤버 접근연산자 앞에 있는 myObj 객체를 this로 반환 합니다.  ",
        "멤버접근연산자는 .과 []대괄호를 의미하며, 그 앞의 객체가 자신을  호출한 것으로 맨처음에 정의한 this의 의미를 다시 생각해볼 수 있습니다.",
        "다음예제입니다.  여기서의 this는 뭐라고 출력될까요? ",
        "결과는 c입니다.  sayName이라는 함수라고 선언되어 있지만, 이가 'say'라는 메서드가 되었기때문에, 해당 메서드 앞있는 c가 this가 되는 거죠. ",
        "아래와 같이 b객체가 선언되고 마지막문을 실행하면 어떻게 될까요? ",
        "b의 c는 c를 가리키고 있고 ",
        "c의 say는 function sayName을 가리키고 있습니다. 따라서 앞의c.say()와 같이, this로 c가 출력되게 됩니다. ",
        "함수와 메서드의 상황을 비교해보자면, 같은 함수를 쓰더라고 함수로서 쓰일때는 window를 뜻하고, 메서드로서 쓰일 때는 멤버접근연산자 앞의 객체를 뜻하는 것을 확인할 수 있습니다.",

        "앞에서 함수는에서는 window라고 기억하고 넘어갔었는데요. 메서드에서의 this를 배웠으니 ",
        "스코프가 중첩되면서 생기는, 함수이지만 짱 헷갈리는 상황 두가지를 예제와 함께 보겠습니다. ",
        "먼저 함수안의 함수에서의 상황입니다. 해당 예제를 실행하면 어떻게 될까요? ",
        "함수 a의 선언다음 함수 a를 호출하면 2번째 줄의 콘솔로그 this가 실행됩니다. 이는 함수안의 this이므로 window로 출력됩니다. ",
        "그다음으로 함수 b의 선언이 있고 이를 호출하면, 5번째 줄이 실행되고. 이 역시 함수안의 this이므로 window로 출력됩니다. ",
        "함수 C 역시 동일하게 실행되죠. ",
        "결국 모두 \"함수\"로서 그안의 콘솔로그 this가 실행되기 때문에 모두 window를 의미합니다. ",

        "다음으로 메서드의 내부함수에서의 상황입니다. 해당 코드의 결과는 뭘까요? ",
        "먼저 usr.sayHello()를 실행하면 유저의 메서드인 sayHello가 실행되어 디스는 이를 호출하는 user객체를 가리킵니다. ",
        "이제 sayHi() 메서드를 실행해볼까요? 어떤 결과값이 나올것 같나요? ",
        "해당 매서드의 내부에는 arrow라는 함수가 선언되어있고, 내부에서 arrow함수를 호출합니다. ",
        "arrow는 메서드로서가 아닌 단지 메서드 안에 있는 함수이기 때문에 윈도우가 this로서 출력됩니다. ",
        "결국 user의 sayHi라는 메서드를 사용해도 메서드 안에서는 arrow라는 함수가 실행되는 거죠. ",
        "결국 해당예제에서 두 메서드 실행해도 각각의 최종적 실행문은 다르기때문에 이런 결과가 발생합니다. ",
        "정리해보자면 어디에 있는 함수라면 ",
        "window라는 거죠! 무조건이라는 수식어를 붙이고 싶지만 안타깝게도 그러진 않습니다. ",
        "앞서 개발자가 설계상의 오류라고 인정한 것처럼, 이러한 상황은 논리적으로 이상하게 느껴집니다. ",
        "따라서 es6에서는 이런 문제를 보완하고자 this바인딩이 일어나지않는 화살표 함수를 도입했습니다. ",
        "이전 예제를 통해 비교해보자면, 똑같은 코드지만 일반함수에서는 window를, 화살표 함수에서는 user를 반환하고 있습니다. ",
        "상위 스코프인 sayHi()를 기준으로 이를 호출한 객체인 user를 반환하는 것입니다. ",

        "따라서 함수라면 무조건 window가 아니라 ",
        "일반 함수의 경우 어떤상황에서도 window를 가르키지만, 화살표라면 상위스코프의 this라고 할 수 있겠습니다. ",
        "이때까지 배운 것들을 정리하자면 ",
        "전역공간에서는 브라우저환경, Node.js 환경 엄격모드에서 이와 같은 차이가 있지만, 브라우저를 기준으로 window라고 이해하면 되고요. ",
        "함수는 전역과 같이 window, 메서드에서는 멤버접근 연산자 앞의 객체가 this로 정의됩니다. ",
        "함수에서는 헷갈리는 상황들이 있었는데, 먼저 함수안의 함수라거나, ",
        "메서드 내부의 함수라면, 논리적이지 않아보이지만 결국 모두 함수이므로 window를 가리킵니다. ",
        "끝으로 이를 보완하기 위해 나온 화살표함수는 일반함수와 달리 상위스코프가 this가 됩니다.",
        "그 외에도 콜백함수, 생성자함수에서의 this도 있고 따로 this를 지정할 수 있는 메서드들도 존재하므로 시간이 있다면 한번 찾아보시면 좋겠습니다."
    ],
    "JSON과 메서드": [
        "JSON은 데이터를 저장하거나 전송할 때 많이 사용하는 경량의 데이터 교환 형식입니다. 특정 언어에 종속되지 않고, 대부분의 프로그래밍 언어에서 JSON 포맷의 데이터를 핸들링 할 수 있는 라이브러리를 제공하기에 서버와 클라이언트 간의 교류에서 일반적으로 사용됩니다. ",
        "제이슨의 메서드는 두가지로, 객체를 JSON으로 변환하는 stringify와 JSON을 객체로 변환하는 parse가 있습니다.  ",

        "먼저 stringify입니다. 스튜던트라는 객체를 해당 메서드의 인자로 넣어 실행할 경우 이와 같은 json 형식으로 바뀌며 ",
        "또한 마지막 실행문에서 볼 수 있듯이 제이슨의 타입은 문자열입니다. ",
        "객체 외에도, 배열, 문자, 숫자 불린값, 널도 제이슨화 될 수 있으며, 문자열의 경우 무조건 큰따옴표가 추가됩니다. ",
        "이와 반대로 함수, 심볼형, 값이 언디파인인 프로퍼티는 적용이 불가능하여 예제 코드의 겨웅 모두 무시당해 빈객체가 출력됩니다.",

        "stringify의 장점에는 예시와 같이 room안에 number 같이 중첩된 객체도 알아서 문자열로 바꿔준다는 것이 있으며,",
        "또한 date 객체를  stringify했을 경우 자동으로 문자열로 반환됩니다. ",
        "인자로 인코딩하는 값을 넣는게 일반적이지만 옵셔널하게 replacer와 space가 두,세번째 인자로 들어갈 수 있습니다. ",
        "replacer 는 인코딩하길 원하는 프로퍼티가 담긴 배열 또는 매핑 함수인데요, 제이슨으로 변환되길 원하는 값만 두번째 인자에 배열형식으로 넣으면 해당 값만 변환 됩니다.",
        "유의할 점은 중첩된 객체일 경우 안에 있는 프로퍼티의 이름도 넣어야 해당 값이 출력됩니다. ",
        "서로 참조하는 순환참조의 경우 복잡하기 때문에 stringfy 되지 않는데요. ",
        "따라서 순환 참조를 발생시키는 프로퍼티 room.occupiedBy만 제외하고, ('place', 'number')를 포함한 모든 프로퍼티를 배열에 넣으면 ",
        "아래와 같은 결과가 출력됩니다. ",

        "복잡한 배열대신 함수를 전달해서 간결하게 이 문제를 해결할 수 있는데요, replacer 함수는  3번째줄의 실행 결과와 같이 (키, 값) 쌍인 프로퍼티 전체를 대상으로 호출됩니다. ",
        "특정 프로퍼티를 누락시키려면 값을 undefiend로 만들어야하는데요. 따라서 4번째 줄과 같이 명령하면 앞의 복잡했던 배열을 넣는 방식과 같은 결과가 도출됩니다. ",

        "stringify의 마지막 파라미터인 space는 공백 문자의 수를 의미하는데요 기존에는 줄바꿈과 띄어쓰기 없이 출력되는 반면, 마지막 문자처럼 스페이스를 2로 지정한 경우 줄바꿈과 들여쓰기 등이 적용되어 가독성을 높일 수 있습니다. ",

        "마지막으로 parse(펄스)는 역으로 JSON을 객체로 변환하는 메서드 입니다. json 형태의 useData를 parse하면 객채형태로 변환되어 friends의 인덱스1번째 값이 1임을 확인할 수 있습니다. ",
        "json을 작성할때 주의사항은 프로퍼티의 키, 값 모두 문자열일 경우 무조건 “큰따옴표”를 사용해야하며, 순수한 값만 사용 가능하기에 new 객체는 올바르지 못한 형식입니다. 또한 이 코드는 편의를 위해 주석이 달려있지만 JSON은 이와 같은 주석 작성은 지원하지 않습니다. ",
        "parse에도 2번째 인자로 변환 결과를 반환하기 전에 이 인수에 전달해 변형하는 함수를 받을 수 있는데요, 원래 이와 같은 date값은 단순 문자열로 인식하여 객체화되기 때문에 Date 메서드의 사용이 불가능합니다. ",
        "하지만 key가 데이트이면 그 값을 Date 생성자함수를 통해 date객체로 변환화는 함수를 인자로 넣으면 그렇게 객체로 변한되어 parse 실행 후 바로 Date 메서드 사용이 가능해집니다."
    ],
    "변수의 유효범위와 클로저": [
        "먼저 변수의 유효 범위에 대해 말씀드리겠습니다. 중괄호로 감싸진 코드블록은  블록 안에서 선언한 변수는 블록 안에서만 사용할 수 있기때문에 밖에서 해당 변수를 찾을 경우 에러가 발생합니다. ",
        "if, for, while 등에서도 마찬가지로  중괄호 안에서 선언한 변수는 오직 블록 안에서만 접근 가능합니다. ",

        "두번째로 중첩함수 입니다.  예제의 getfullname()함수처럼 외부 변수에 접근해 이름 전체를 반환해주는 함수를 중첩 함수라고 하며 자바스크립트에선 중첩 함수가 흔히 사용됩니다. ",
        "이 예제는 호출될 때마다 다음 숫자를 반환해주는 ‘카운터’ 함수입니다. counter를 여러 개 만들어 alert했을때 0 1 2 가 출력되는 것을 확인할 수 있습니다. ",
        "여기서 이렇게 counter를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까요? 함수와 중첩 함수 내 count 변수엔 어떤 값이 할당될까요? ",

        "이에 대한 의문은 풀기 위해서는 렉시컬 환경에 대해 알아야합니다. 자바스크립트에서 실행 중인 함수, 코드 블록 {...}, 스크립트 전체 모두 ‘렉시컬 환경’이라는 내부에 숨겨진 연관 객체를 갖습니다. ",
        "렉시컬 환경은 모든 지역 변수를 프로퍼티로 저장하고 있는 환경 레코드와  외부 코드와 연관된 외부 렉시컬 환경에 대한 참조를 가지고 있습니다.  ",
        "먼저 스크립트 전체에 대한 렉시컬 환경에 대해 알아봅시다. ",
        "이 이미지는 스크립트 전체의 렉시컬 환경을 표현한 것으로, 주황부분이 환경레코드, 연두색 부분이 렉시컬 환경에 대한 참조를 나타냅니다. 이런 렉시컬 환경을 전역 렉시컬 환경이라고 합니다. ",

        "스크립트의 흐름과 함께 살펴보겠습니다. 먼저 스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라갑니다.  이때 변수의 상태는 특수 내부 상태인 'uninitialized’로 변수 pharse가 올라간것을 볼 수 있습니다. 이때 자바스크립트 엔진은 변수를 인지는 하지만, let을 만나기 전까진 이 변수를 참조할 수는 없습니다. ",
        "let phrase가 나타났네요. 아직 값을 할당하기 전이기 때문에 프로퍼티 값은 undefined입니다. 하지만 이 시점 이후부터 변수를 사용할 수 있습니다. ",
        "따라서 hello나 bye등의 값을 phrase에 할당될 수 있습니다. ",
        "변수는 렉시컬 환경 중 현재 실행 중인 함수와 코드 블록, 스크립트와 연관되어 있는 환경 레코드의 프로퍼티가됩니다. 따라서 변수를 변경하면 환경 레코드의 프로퍼티가 변경된다고 할 수 있습니다. ",

        "이렇게 스크립트에 함수 선언문이 있으면 어떻게 될까요? 변수는 let을 만나 선언이 될 때까지 사용할 수 없는 반면에, 함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있게 됩니다. 호이스팅 된다고 할 수 있겠습니다. 하지만 모든 함수가 이런 것은 아니며 함수를 변수에 할당한 함수 표현식은 해당하지 않습니다. ",

        "이어서 say(\"John\")을 호출해봅시다. 이를 호출할 경우 이처럼 값이 John인 name 변수를 프로퍼티로가진 함수 say의 렉시컬 환경과, phrase와 함수 say를 프로퍼티로 가진 전역 렉시컬 환경 두 개의 렉시컬 환경이 만들어집니다.",
        "여기서 코드에서 변수에 접근할 때, 먼저 내부 렉시컬 환경을 검색 범위로 잡고, 없다면 외부 렉시컬 환경으로 확장시킵니다는 것을 알아야합니다. 이 사실을 인식하고 다음 스크립트의 흐름을 파악해봅시다. ",

        "함수 say 내부의 alert에서 변수 name에 접근할 때, 먼저 내부 렉시컬 환경을 살펴봅니다. 내부 렉시컬 환경에서 변수 name을 찾아서 john이라는 값을 받아옵니다. ",
        "alert에서 변수 phrase에 접근할 때에는, phrase에 상응하는 프로퍼티가 내부 렉시컬 환경에서 못찾았기때문에 검색 범위는 외부 렉시컬 환경으로 확장됩니다. 이후 외부 렉시컬 환경에서 phrase를 찾아서 Hello라는 값을 받아오게 됩니다. ",

        "이제 makeCounter 예시로 돌아가 봅시다.",
        "이전에서 살펴본 say(\"John\") 예시와 마찬가지로 makeCounter()를 호출할 때도 두 개의 렉시컬 환경이 만들어집니다. 하지만 이 함수는 앞의 say함수와 달리, count의 값을 1씩 더하는 중첩 함수가 있습니다. 즉 makeCounter()는 이 중첩함수를 반환하는 함수인것입니다. ",

        "여기서 알야하는 사실은 함수는 [[Environment]]라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다는 것입니다. 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다는 것이죠 ",
        "따라서 counter.[[Environment]]엔 {count: 0}이 있는 렉시컬 환경에 대한 참조가 저장됩니다. ",

        "이제 alert( counter())를 호출하는 흐름을 봅시다. count 변수가 필요한데, 먼저 자체 렉시컬 환경에서 변수를 찾지만, 없으므로 이 렉시컬 환경은 비어있는 상황입니다. 이제 외부의 counter() 렉시컬 환경에서 count가 0임을 찾았습니다. 따라서  0이 출력됩니다. ",
        "이후 count++이 실행되면서  count 값이 1 증가하고 실행이 종료됩니다. 이때 카운트 변수값의 갱신은 변수가 저장된 환경에서 이루어집니다. ",
        "즉 count 변수가 저장된 couner()의 렉시컬환경에서 변경이 되는 것이므로, 다음에 counter()를 호출하면 1로 출력되고 count 변수가 2로 증가하는 것입니다. ",

        "이제 클로저에 대해 알아봅시다. 클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수입니다. 앞에서 알아봤듯이, 자바스크립트에서 함수는 [[Environment]]를 통해 자신이 어디서 만들어졌는지를 기억하고 이를 사용해 외부 변수에 접근합니다. 즉 자바스크립트에서는 모든 함수가 자연스럽게 클로저라고 할 수 있습니다.",
        "하지만 예외는 존재합니다. 이에 대해서는 두번째 발표에서 다루도록하겠습니다."
    ],
    "new Function 문법": [
        "new Function 문법은 이와 같습니다. arg1부터 argN까지의 인수와 함수 본문 functionBody로 구성된 새로 만들어지는 함수를 만들 수 있습니다.",
        "예시의 sum 썸함수는  new Function으로 만들어진 인자 두개 (a,b)를 받아 둘의 합을 반환하는 함수입니다. ",
        "3가지 모두 같은 함수를 만드는 방식입니다. ",
        "여기서 눈에보이는 기존 방식과의 차이점은  런타임에 받은 '문자열'을 사용해 함수를 만들 수 있다는 점입니다. 즉 서버에서 전달받은 문자열을 이용해 새로운 함수를 만들고 이를 실행하는 것도 가능하다는 뜻입니다. ",
        "따라서 서버에서 코드를 받거나 템플릿을 사용해 함수를 동적으로 컴파일해야 하는 경우나, 복잡한 웹 애플리케이션을 구현할 때와 같이 아주 특별한 경우에 new Function을 사용할 수 있습니다. ",
        "다시 앞서 이야기한 클로저에 대해 복기해봅시다. 자바스크립트에서 함수는 [[Environment]]를 통해 자신이 만들어진 렉시컬 환경를 참조하고 , 함수 본문에선 이를 사용해 외부 변수에 접근합니다. ",
        "하지만 new Function을 이용해 함수를 만들면 함수의 [[Environment]] 프로퍼티가 현재 렉시컬 환경이 아닌 전역 렉시컬 환경을 참조하게 됩니다. 따라서 new Function을 이용해 만든 함수는 외부 변수에 접근할 수 없고, 오직 전역 변수에만 접근할 수 있습니다. 즉 new Function 문법을 사용한 함수는  클로저가 아닙니다. ",

        "예시와 함께 살펴보겠습니다. 일반적 문법의 함수가 중첩함수로 선언됐을 경우 getFunc()외부 렉시컬 환경의 test라는 벨류를 가져올 수 있습니다 ",
        "하지만 newFunction 기법으로 선언되었을때는   getFunc()외부 렉시컬 환경이 아닌 전역 렉시컬환경을 참조하기 때문에 벨류를 찾지못해 오류가 발생합니다. 이는 에러를 예방해 준다는 관점에서 장점이라 할 수 있으며, 일반적으로 매개변수를 사용해 값을 받는 게 더 낫습니다. 문자열을 사용해서 함수를 만들어야하는 상황 등, 실무에선 이 기능이 아주 유용하게 쓰인다고합니다.  "
    ],
    "클래스의 기본": [
        "클래스는 많이 들어왔듯이, 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀로, 기본적인 문법은 이와 같습니다 ",
        "예제와 함께 살펴보겠습니다. 유저 클래스를 생성하고, new User(\"John\")를 호출하면, 먼저 새로운 객체(인스턴스)가 생성됩니다. 다음으로 넘겨받은 인수와 함께 constructor가 자동으로 실행되고, 이때 인수 \"John\"이 this.name에 할당됩니다. ",
        "class User 문법 구조가 진짜 하는 일은 다음과 같은데요, 먼저 constructor의 코드를 본문으로 갖는 User라는 함수를 생성하고, sayHi같은 클래스 내에서 정의한 메서드를 User.prototype에 저장합니다. ",
        "클래스는 예제와 같이 함수처럼 클래스 표현식으로도 선언할 수 있는데요.  다른 표현식 내부에서 정의, 전달, 반환, 할당할 수 있습니다. ",
        "또 객체처럼 클래스도 getter나 setter를 지원하여 예제와 같은 코드를 작성할 수 있습니다. constructor 메서드가 실행될 때 setter를 활성화시키고, 다른 메서드와 같이 getter와 setter 역시 User.prototype에 정의됩니다. ",
        "박스친 부분의 첫줄과 마지막줄처럼,  new User(value)를 실행할 때 getter메서드가 실행되고, 두번째 줄과 같이 user.name 을 실행할 때 setter메서드가 실행됩니다. ",
        "또한 리터럴을 사용해 만든 객체처럼 클래스도 계산된 프로퍼티를 지원하는데요, 말은 어렵게 느껴지지만 대괄호를 이용하면 박스 친것과 같이 say와 Hi 문자열을 합쳐 sayHi 메서드를 사용할 수 있습니다.",
        "마지막으로 클래스 필드입니다. 클래스 필드 문법을 이용하면 어떤 종류의 프로퍼티도 클래스에 추가가 가능합니다. 예시처럼 constructor 메서드가 아닌 그냥 밖에 프로퍼티 이름을 지정하는 것으로, 구식에서는 지원은 안할 가능성이 있습니다. ",
        "앞서 말했던 것처럼  prColor와 같이 복잡한 표현식이나 함수 호출 결과를 사용할 수 있습니다. 첫번째 박스처럼 선언 후 new User를 호출할때 프롬트가 나와 값을 설정해주면, 마지막 줄에서  앞서 입력한 값이 alert되는 것을 확인할 수 있습니다. ",
        "이러한 클래스 필드 문법으로 화살표함수를 사용하는 것은 메서드를 이벤트 리스너로 설정해야 할 때 특히 유용합니다. js에서 this는 동적이기때문에 일반함수로 선언할 경우, setTime함수의 콜백함수로 쓰이면 this를 찾지 못하지만, 화살표함수로 선언할 경우에는 각 Button 객체마다 독립적인 함수를 만들어주고 이 함수의 this를 해당 객체에 바인딩시켜, this엔 항상 의도한 값이 들어가게 됩니다. "
    ],
    "클래스의 상속": [
        "먼저 부모 클래스가될 애니멀입니다. 객체 animal과 클래스 Animal의 관계를 그림으로 나타내면 다음과 같으며,  뉴 애니멀(\"동물\")을 호출하면  인스턴스 에니멀이 생성되고 네임에 \"동물\"이 할당됩니다. ",
        "이런 애니멀 클래스를 예시와 같이 extends 키워드를 통해 레빗 클래스에 상속 시킬 수 있습니다. ",
        "이때의 구조를 그림으로 보면, extends는 Rabbit.prototype.[[Prototype]]을 Animal.prototype으로 설정합니다. 그렇기 때문에 Rabbit.prototype에서 메서드를 찾지 못하면 Animal.prototype에서 메서드를 가져옵니다. ",
        "엔진이 rabbit.run의 존재를 확인하는 흐름을 보자면, 먼저 아래부터 객체 rabbit에 run이 있나 확인하여 run이 없는 것을 보고, rabbit의 프로토타입인 Rabbit.prototype에 메서드가 있나 확인합니다. hide는 있는데 run은 없으므로, extends를 통해 관계가 만들어진 Animal.prototype에 메서드가 있나 확인하고 메서드 run을 찾아 이를 실행합니다. 민지님이 말씀해주신 프로토타입 상속의 경우라고 볼 수 있겠습니다. ",

        "이렇듯 특별한 사항이 없으면 class Rabbit은 class Animal에 있는 메서드를 ‘그대로’ 상속받습니다. 그런데 Rabbit에서 부모 클래스인 animal에 있던 메서드를 자체적으로 정의하면, 상속받은 메서드가 아닌 자체 메서드가 사용할 수 있는데요, 이런것을 메서드 오버라이딩이라고 합니다. 생성자 메서드 오버라이딩을 정의하자면, 자식 클래스가 자신의 슈퍼 혹은 부모 클래스들 중 하나에게 제공받은 생성자나 메서드를 특정한 형태로 구현하는 것을 뜻합니다. ",
        "이는 슈퍼를 통해 구현할 수 있는데요,  이와 같은 형식으로 부모 클래스의 메서드와 생성자를 호출합니다. ",
        "다시 레빗 클래스와 함께 살펴보겠습니다.  먼저 생성자 오버라이딩입니다. super(name) 을 통해 부모 생성자 name를 호출하고, 우측의 rabbit 인스턴스에서 인자로 받은 값 \"흰 토끼\"를 name으로 할당합니다. 또한 class Animal에 있는 speed와  class Rabbit에 추가된 earLength도 접근이 가능합니다. ",
        "다음은 메서드 오버라이딩 입니다. super.stop()을 통해 부모 메서드 stop()을 호출해 멈추고, hide()까지하도록, 기존의 애니멀의 스탑 메서드를  Rabbit의 stop()으로 수정할 수 있습니다. 또한 class Animal에 있는 run() 역시 호출할 수 있습니다. ",
        "마지막으로 슈퍼는 setTimeout과 같은 이벤트 리스너의 콜백함수로 사용할 때 일반 함수로 정의하면 오류가 발생함으로, 화살표함수를 사용해야합니다. "
    ],
    "\"try catch\"와 에러 핸들링": [
        "try catch을 사용하면 에러 발생 시 스크립트가 죽는 걸 방지하고, 에러를 잡을 수 있습니다. 해당예제에서 에러가 없을 경우에는 try문 안에 있는 (1)과 (2)만 실행합니다. ",
        "하지만 lalala라는 정의되지않은 변수로 에러가 발생하면 에러발생성 전 1만 실행하고 2는 실행하지않은 상태에서 바로 catch문 안의 (3)이 실행됩니다. ",

        "이러한 try catch문은 동기적으로 동작합니다. 따라서 비동기 함수 안의 에러를 잡아내지 못합니다. ",
        "그러므로 예제처럼   try catch를 반드시 비동기처리되는 함수 내부에 구현해야합니다. ",

        "에러 객체에 대해 알아봅시다. 에러 객체는 에러이름인 name, 에러의 상세 내용을 담고있는 메세지, 에러를 유발한 중첩 호출들의 순서 정보를 가진 문자열인 스택 프로퍼티를 가지고 있습니다. 일반적으로 에러 자체를 호출하면 박스친 부분과 같이 \"네임: 메세지\"형태의 문자열을 반환합니다. ",
        "자바스크립트에서 에러 객체의 종류는 다음과 같으며 예제 코드처럼 생성 연산자를 사용해 만들 수 있습니다. SyntaxError는 \"{\" 를 빼먹는 등의 언어 사양을 따르지 않을 때 발생하며, ReferenceError는 정의되지 않은 변수가 있을 때 발생합니다. TypeError는 말그대로 함수 또는 변수의 값이 예상치 못한 유형일 때 발생하며 타입에 맞지않은 메서드를 사용하면  00.map is not a function과 같은 에러 메세지와 함께 출력됩니다. ",

        "다음으로 throw 연산자에 대해 알아봅시다. 예제의 json 변수는 문법적으로 잘못되진 않았지만, 스크립트 내에서 사용 중인 필수 프로퍼티 name을 가지고 있지 않습니다. 스크립트는 원하는대로 실행되지않지만 에러가 따로 발생하지는 않습니다. ",
        "따라서 이처럼 네임프로퍼티가 없을때, throw 연산자와 에러 생성 연산자를 사용해 name이 없다는 메세지를 담은 새로운 에러 객체를 만들어 던질 수 있습니다.해당 스크립트를 실행하면 에러가 발생했으므로 try의 실행은 즉시 중단되고 제어 흐름이 catch로 넘어가 얼럿 창에 마지막 박스의 내용이 출력되게 됩니다. ",

        "또한 트라이캐치문은 파이널리라는 절을 더 가질 수 있는데요. 예제와 같은 형식으로 작성할 수 있고 어떤 상황이라도 마지막에는 파이널리 절안의 코드가 실행됩니다.  ",
        "해당예제에서 \"에러를 만드시겠습니까?\"에  예로 답한 경우에는 try -> catch -> finally 순으로 모두 실행되며,  아니오라고 답한 경우에는 try후 바로 finally가 실행됩니다. ",

        "finally 절은 try..catch 절을 빠져나가는 어떤 경우에도 실행되는데요.  return을 사용해 명시적으로 빠져나가려는 경우도 마찬가지입니다. ",
        "따라서 해당 예제에서도 try에 리턴 1이 있더라도 finally 안의 alert가 실행되고 난 후, return 실행되어 다음과 같은 순서로 alert창이 나오게 됩니다. ",

        "finally 없이 그냥 트라이캐치문 밑에 해당코드를 작성해도 차이가 있을까 하는 의문이 들 수 있는데요. 이는 try catch문에 빠저나오게하는 코드가 있다면 차이점이 있습니다. 처음의 finally의 경우 앞서본 예제처럼 리턴이 있음에도 초기화가 콘솔에 찍히지만 후자의 경우 찍히지않습니다.  ",
        "리턴이 아니라 throw로 에러를 던지는 것 역시 원래는 바로 함수 f를 빠져나와야하지만 finally절이 있다면 초기화를 콘솔에 찍고 에러가 던져진 것을 확인할 수 있습니다 "
    ],
    "async와 await": [
        "함수앞에 async가 붙으면 반드시 프로미스를 반환하고, 프로미스가 아닌 것은 프로미스로 감싸 반환합니다. 해당 함수는 결과가 1인 resolved 프로미스가 반환된되므로 마지막 문을 실행하면 1이 alert되는 것을 확인할 수 있습니다. ",

        "다음으로 async 함수 안에서만 동작하는 await는 말그대로 프로미스가 처리될 때까지 함수의 실행을 기다립니다. 해당예제는 프로미스가 이행될때까지 1초를 기다리고 '완료'가 출력되는 것을 확인할 수 있습니다. 1초동안 시간을 낭비한다고 생각할 수 있지만 프로미스가 처리되길 기다리는 동안엔 엔진이 다른 스크립트를 실행, 이벤트 처리 등의 다른 일을 할 수 있기 때문에, CPU 리소스가 낭비되지 않습니다. ",

        "또한 클래스의 메서드 이름 앞에 async를 추가하면 async 클래스 메서드를 선언할 수 있습니다.",

        "다음으로 에러핸들링입니다. await가 던진 에러는 throw가 던진 에러를 잡을 때처럼 try..catch를 사용해 잡을 수 있으며, 예제처럼 여러 줄의 코드를 try로 감싸는 것도 가능합니다. ",

        "만약 try..catch가 없으면 f()를 호출해 만든 프로미스가 rejected 상태가 되고 이에 .catch를 추가하여 처리가 가능합니다. ",

        "async/await를 사용하면 읽고, 쓰기 쉬운 비동기 코드를 작성할 수 있습니다. 다음 예제는 깃허브사용자의 정보를 읽고 3초간 프로필을 보여주는 함수입니다. .then 대신 await을 앞에 붙여 패치함수로 리스폰스 객체를 받아오는 것을 기다리고 다음으로 이를 제이슨화합니다. 그다음 깃허브사용자 정보 역시 같은 과정을 거치고 해당 정보에서 아바타의 유알엘을 이미지의 소스로 들고와 보여줍니다. ",

        "이미지와 같은 이미지가 보이게되고 이후 삼초 대기 후 이미지가 사라지게됩니다. ",

        "결론적으로 async/await을 사용하면 await가 대기를 처리해주기 때문에 .then이 거의 필요없어집니다. 에러를 다룰 때에는.catch 대신 일반 try..catch를 사용할 수 있다는 장점이 있으며, 대체로, promise.then을 사용하는 것보다 async/await를 사용하는 것이 더 편리합니다. "
    ],
    "연산자": [
        "형변환이 왜 필요할까요? 문자형과 문자형을 더하면 문자형이 됩니다. 'hello' + 'world' = 'hello world' 만약 문자와 숫자를 더하면 의도치 않은 현상이 발생됩니다. a에 50 b 60을 입력하면 어떤 결과가 나올까요? 결과값은 5060이 나오게됩니다. prompt 창을 이용하여 a,b의 값을 받고 a,b의 합을 result에 담아 console.log로 result를 찍어보면 원하는 값이 안나오게 됩니다. 그 이유는 prompt로 입력받은 값은 문자형으로 인식이 됩니다. 그래서 “50”+”60” = 5060이라는 값이 나오게 된 것입니다. 우리가 원하는 결과값이 나오게 하려면 형변환이 필요합니다.",

        "자바스크립트의 형변환은 ‘암시적변환’과 ‘명시적변환’ 두 가지가 있습니다. 암시적변환(자동 형변환)은 자바스크립트 엔진이 필요에 따라 자동으로 데이터타입을 변환시키는 것입니다. 자동 형변환은 자동으로 돼서 편리하다 생각하지만 원인을 찾기 힘든 에러를 발생할 수 있습니다. 이를 위해 명시적 형변환 (강제 형변환)을 사용합니다. 명시적 변환은 데이터 타입을 직접 변환 시키는 것입니다. 명시적 형변환에는 String(), Number(), Boolean() 있습니다.",

        "String()은 괄호안에 있는 값을 문자형으로 반환시켜줍니다. String(2)은 문자형 2로 String(null)은 문자형 null, String(true)는 문자형 true로 반환됩니다.",

        "Number()는 괄호안에 있는 타입을 숫자형으로 반환시켜줍니다. 사용자로 받은 입력값이 문자형일 경우 자주 쓰입니다. 아까 봤던 prompt예시에서 쓰이겠죠? Number('1234')는 문자형 1234를 숫자형 1234로 반환시켜줍니다. 만약에 문자열 안에 숫자 이외의 글자가 들어있으면 NaN이 됩니다. Number('123aaa')는 NaN이 됩니다. Number(true)는 1을 반환하고 false는 0을 반환합니다.",

        "주의할 점으로는 Number(null)는 0, Number(undefined)는 NaN이 나옵니다.",

        "Boolean()은 논리 연산을 수행 할 때 발생합니다. Boolean()의 false 케이스는 숫자 0, 빈 문자열, null, undefined, NaN 으로 그 외의 값들은 모두 true를 반환합니다.",

        "주의할 점은 Boolean(0)은 false값이 나오고 Boolean('0')은 true가 나옵니다. Boolean('')는 false Boolean(' ')는 true가 반환됩니다.",

        "산술 연산자는 수학적 계산을 수행하는 연산자입니다. 덧셈의 기호로 '+', 뺄셈의 기호로 '-', 곱셈의 기호로 '*', 나눗셈의 기호로 '/', 나머지의 기호로 '%', 거듭제곱의 기호로 '**'를 사용하여 수학적 연산을 수행할 때 사용됩니다.",

        "연산자 우선순위는 프로그래밍 언어에서 연산자가 표현식 내에서 어떤 순서로 실행되어야 하는지를 결정하는 규칙입니다. 괄호 안의 표현식이 가장 높은 우선순위를 가지며 대입 연산자가 가장 낮은 우선수위를 가집니다.",

        "증가 감소 연산자는 숫자를 하나 늘리거나 줄이는 연산자입니다. 증가(increment) 연산자 ++는 변수를 1 증가시키고 감소(decrement) 연산자 --는 변수를 1 감소시킵니다. '++'와 '--' 연산자는 변수 앞이나 뒤에 올 수 있습니다. counter++ 와 같이 피연산자 뒤에 올 때는 후위형(postfix form), ++counter와 같이 피연산자 앞에 올 때는 전위형(prefix form)입니다. 후위형은 증가시키긴 하지만 증가 전의 기존 값을 반환하고 전위형은 증가시킨 값을 반환합니다.",

        "비교연산자를 사용하면 값을 반환하는데 불린형으로 반환합니다.",

        "문자열은 어떻게 비교할까요? 사전 순으로 사전 뒤쪽의 문자열이 앞쪽 문자열보다 크다고 판단합니다. 첫 번째 글자가 같으면 그 뒤에 있는 글자를 비교하는 방식으로 진행됩니다. 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 정해지고 대문자와 소문자를 비교하였을 때 소문자가 더 크다고 판단합니다.",

        "a는 숫자형 1, b는 문자형 1로 지정하여 비교해보면 동등연산자는 true, 일치연산자는 false가 나옵니다. 동등연산자는 0과 false를 구별하지 못합니다. 0과 false를 구분하려면 일치연산자를 사용해야 합니다. 일치연산자는 타입까지 비교해주기 때문에 에러가 발생할 확률을 줄여주므로 가급적이면 일치연산자를 사용하는게 좋습니다.",

        "if문은 괄호안에 들어간 문이 true면 실행합니다. else는 if문이 false일 때 실행하고 else if는 조건을 여러 개 처리해야 할 때 사용합니다. 물음표 연산자라고도 불리는 조건부 연산자를 사용하여 if문을 더 간단하게 표현할 수 있습니다. if문을 활용한 예시를 조건부 연산자를 사용하여 이렇게 바꿀 수 있습니다.",

        "|| or은 여러개 중 하나라도 true라면 true를 반환합니다. 즉 모든 값이 false라면 false를 반환합니다. and는 모든 값이 true라면 true를 반환합니다. 즉 하나라도 false면 false를 반환합니다. not은 true면 false를 반환하고 false면 true를 반환합니다",

        "OR 연산자가 여러 개의 경우에는 왼쪽부터 시작해 true면 연산을 멈추고 첫번쨰 truthy를 반환하고 피연산자에 truthy가 없다면 마지막 피연산자를 반환합니다. AND 연산자가 여러 개의 경우에는 왼쪽부터 시작해 false면 연산을 멈추고 첫번째 falsy를 반환하고 피연산자에 falsy가 없다면 마지막 값을 반환합니다.",

        "nullish 병합연산자를 사용하여 확정되어있는 변수를 찾을 수 있습니다. 왼쪽부터 시작해 null, undefined 값이 아닌 값을 반환합니다. or 연산자와 nullish의 차이는 or는 첫 번째 truthy 값을 반환하고 ??는 첫 번째 정의된 값을 반환합니다."
    ],
    "new와 생성자": [
        "객체 리터럴을 사용하면 객체를 간단하게 만들 수 있지만, 비슷한 여러 객체를 만들어야 할 때는 생성자 함수를 사용하는 것이 효율적입니다. 생성자 함수를 이용하면 객체를 손쉽게 여러 개 만들 수 있습니다. 이를 비유하자면, 생성자 함수는 객체를 만들기 위한 템플릿이라고 볼 수 있습니다. 필요한 속성과 동작을 정의하고, 그 템플릿을 사용하여 여러 객체를 생성할 수 있습니다.",

        "생성자 함수는 함수 이름이 첫글자가 대문자로 시작하여 코드의 가독성을 높이고 생성자 함수와 일반 함수를 구별할 수 있습니다.",

        "생성자 함수를 호출할 때는 보통 new 키워드를 사용합니다. new를 통해 생성자 함수가 새로운 객체를 반환하고 이 객체에 속성과 메서드를 추가할 수 있습니다.",

        "생성자 함수가 어떻게 돌아가는지 알아보겠습니다. new User를 실행하면 빈 객체를 만들고 this에 할당합니다. this에 프로퍼티를 추가하여 반환합니다. 이렇게 객체를 만들면 아까 본 객체 리터럴보다 일관성있고 빠르게 객체를 만들 수 있습니다. 어떤 함수라도 new를 붙이고 함수명을 써주면 이 알고리즘이 수행됩니다. 생성자 함수는 재사용이 가능하여 객체를 여러개 만들어야 하는 경우에 사용하면 좋습니다.",

        "생성자함수에 메소드를 추가해보면 this로 할당된 객체에 text 메소드를 추가하였습니다. user1.text에 this는 user1의 age가 됩니다.",

        "만약에 new를 안붙이면 어떻게 될까요? new를 안붙이면 undefined를 반환합니다. new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출돼서 undefined로 호출이 됩니다. 일반 함수로 호출되면 return값이 없어 undefined가 반환됩니다."
    ],
    "Symbol": [
        "자바스크립트의 객체 프로퍼티는 문자형과 심볼형만 가능합니다. 여기서 심볼은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값입니다. 심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키를 만들기 위해 사용합니다. 심볼을 생성할 때는 Symbol 함수를 호출합니다. new 연산자를 사용하면 TypeError가 발생합니다.",
        "a를 입력하면 심볼이 나오고 b를 입력하면 심볼이 나옵니다. 둘다 빈값으로 같아 보이지만 false가 반환됩니다. 그이유는 Symbol은 유일한 식별자이기 때문에 둘이 값이 완전히 다릅니다.",
        "심볼을 만들 때에는 심볼 이름이라 불리는 설명을 만들 수 있습니다. 이 문자열은 Symbol 생성에 어떠한 영향을 주지 않으며 디버깅 용도로만 사용됩니다. 이미지 코드 또한 같아 보이지만 false가 반환됩니다. 생성된 심볼은 항상 유일하며, 같은 심볼을 생성하려고 하면 항상 새로운 심볼이 반환됩니다.",
        "심볼은 자동 형 변환이 되지않습니다. alert함수는 거의 모든 값을 인자로 받을 수 있는데 심볼형은 예외입니다. 자바스크립트에서는 언어 차원의 보호 장치를 마련해 심볼형이 다른 형으로 변환 되지 않게 막아줍니다. 심볼을 출력하고 싶다면 뒤에 .toString() 메서드를 이용하여 호출해줍니다.",
        "만약 설명만 보여주고 싶다면 symbol.description 프로퍼티를 이용하여 호출합니다.",
        "심볼을 객체 프로퍼티로 사용해보겠습니다. 대괄호를 사용해 심볼형 키를 만들어야 합니다. 객체의 프로퍼티 키를 심볼을 사용하면 다른 프로퍼티와 충돌하지 않은 키를 생성할 수 있습니다.",
        "코드를 보면 for in문을 이용하여 key값을 반환하면 name만 반환합니다. 그 이유는 심볼로 만들어진 키는 for in문, Object.keys(), Object.getOwnPropertyNames()와 같은 메소드에는 반환하지 않습니다. 이 특성을 활용하여 심볼로 선언된 키 값들을 숨길 수 있습니다. 이를 통해 객체에 추가된 속성 중에서 외부에서 사용할 필요가 없는 속성을 숨길수 있고, 객체의 인터페이스를 더욱 명확하고 간결하게 만들 수 있습니다. 만약 심볼로 선언된 키 값을 보고 싶다면 Object.getOwnPropertySymbols()를 통해서 가져오면 됩니다. 이 메서드를 사용하면 객체에 추가된 모든 심볼 속성을 배열로 가져올 수 있습니다.",
        "여러 파일에 걸쳐 사용가능한 심볼을 생성하려면 Symbol.for() 메서드와 Symbol.keyfor() 메서드를 사용하여 전역 심볼 레지스트리에 심볼을 설정하고 가져올 수 있습니다. Symbol.for메서드는 인자로 전달받은 문자열을 키로 사용하여 Symbol 값들이 저장되어 있는 전역 Symbol 레지스트리에서 해당 키와 일치하는 저장된 Symbol값을 검색합니다. 검색된 Symbol값을 반환하고 없다면 새로운 Symbol값을 생성하여 전역 Symbol 레지스트리에 저장후 Symbol값을 반환합니다. Symbol.keyFor는 전역 심볼의 이름을 반환합니다. Symbol.keyFor는 전역 심볼의 이름을 반환합니다."
    ],
    "Object keys, values, entries": [
        "Object.keys() 는 객체의 속성이름들을 배열 형태로 반환하는 메소드입니다. 코드를 보면 Object.keys() 메소드는 student 객체의 속성이름들을 배열 형태로 반환하며, 반환된 배열은 keys 변수에 할당되어 출력됩니다.",
        "Object.keys() 메소드는 객체의 상속 속성을 제외하고 직접적으로 속성으로 가지고 있는 속성들만을 반환합니다. 이게 무슨 의미인가 보면 JavaScript에서는 객체는 기본적으로 상속을 지원하기 때문에 객체가 상속받은 속성은 자식 객체의 속성처럼 동작하게 됩니다. Object.keys() 메소드는 상속된 속성을 제외하고, 직접적으로 속성으로 가지고 있는 속성들만을 대상으로 합니다. 그러므로 자식객체가 상속받은 속성은 반환하지 않는다는 것이죠. 예시를 들어보면 child는 parent의 a,b라는 속성을 받았지만 Object.keys() 메소드는 직접적인 속성만을 대상으로 하기 때문에 c 속성만 반환합니다.",
        "Object.values() 는 객체의 속성 값들을 배열 형태로 반환하는 메소드입니다. Object.values() 메소드는 student 객체의 속성 값들을 배열 형태로 반환하여 반환된 배열은 values 변수에 할당하여 출력합니다. values 또한 상속 속성을 제외하고 직접적으로 속성을 가지고 있는 속성들의 값들만을 반환합니다. 그러므로 속성 값 3만 반환하게 됩니다.",
        "Object.entries() 메소드는 객체의 속성이름과 값들을 [key, value] 형태의 배열로 반환하는 메소드입니다. Object.entries()메소드는 student 객체의 속성 이름과 값들을 [key, value] 형태의 배열들로 이루어진 배열로 반환하며, 반환된 배열은 entries 변수에 할당되어 출력됩니다",
        "entries 또한 상속 속성을 제외하고 직접적으로 속성을 가지고 있는 속성들의 값들만을 반환합니다.",
        "Object.fromEntries() 메소드는 Object.entries() 메소드와 반대의 역할을 수행하는 메소드 입니다. [key, value] 형태의 배열을 객체로 변환해주는 메소드입니다. entries 배열을 Object.fromEntries() 메소드를 사용하여 객체를 변환하고 출력합니다. 이러한 메소드를 사용하면 [key, value] 형태의 배열을 쉽게 객체로 변환할 수 있습니다.",
        "Object.fromEntries 메소드는 배열의 모든 요소들이 [key, value] 형태의 배열이어야 하며, 배열의 각 요소에서 첫 번째 요소는 반드시 문자열 또는 심볼이어야 합니다. 그렇지 않으면 TypeError가 발생했지만 ECMAScript2022에서는 숫자형도 사용할 수 있게되었습니다. 그러나 이전 버전의 자바스크립트를 사용하는 경우에는 첫 번째 요소가 문자열이나 심볼이어야 합니다. 이러한 메소드를 사용하면 객체의 속성들을 간편하게 다룰 수 있습니다. 이를 통해 반복문을 사용하지 않고도 객체의 속성들을 쉽게 처리할 수 있습니다."
    ],
    "재귀와 스택": [
        "재귀 함수란 자기 자신을 호출하는 함수입니다. 재귀 함수는 자기 자신을 호출해서 계속해서 반복하기 때문에 종료하지 않는 문제가 생깁니다. 그러므로 종료 조건이 반드시 필요합니다. 재귀함수는 같은 구조의 함수를 반복 사용할 때 쓰입니다. 스택은 데이터를 일시적으로 저장하는 자료구조로, 후입선출 원칙에 따라 동작합니다. 후입선출 원칙을 짧게 설명하자면 가장 마지막에 삽입된 자료가 가장 먼저 삭제된다는 원칙입니다. 재귀함수는 자기 자신을 호출하는 함수로 이러한 호출은 스택을 사용하여 동작합니다.",
        "이미지를 보면 왼쪽은 반복문을 이용하여 코드를 작성하였고 오른쪽은 재귀를 이용하여 코드를 작성하였습니다. 재귀 함수를 사용하면 코드의 가독성과 유지보수성을 높일 수 있습니다. 그러나 재귀 함수를 사용할 때는 종료 조건을 명확히 설정하여 무한 재귀에 빠지지 않도록 주의해야합니다. 이 오른쪽에 있는 코드는 종료 조건을 정의하지 않았기 때문에 무한 재귀에 빠지게 됩니다. ",
        "재귀 함수는 기본 조건과 재귀 호출로 구성됩니다. 기본 조건은 재귀 호출을 멈추기 위한 조건으로 재귀함수가 무한히 호출되는 것을 방지합니다. 예시 코드를 보면 n==0이 기본 조건에 해당합니다. 기본 조건에서 n이 0인 경우 1을 반환하고 그렇지 않은 경우에는 n과 factorial(n-1)의 곱을 반홥합니다. 이렇게 함수 내에서 자기 자신을 호출하여 반복하면서 최종적으로 팩토리얼 값을 계산합니다.",
        "재귀 함수의 깊이란, 함수가 자기 자신을 호출하는 중첩 호출의 최대 개수를 말합니다. 예를 들어, 재귀 함수가 처음 호출될 때 깊이는 1이며, 함수가 자기 자신을 호출할 때마다 깊이가 1씩 증가합니다. 자바스크립트 엔진은 호출 스택(call stack)이라는 메모리 영역을 사용하여 함수 호출을 관리합니다. 호출 스택은 함수 호출이 발생할 때마다 스택 프레임을 추가하고, 함수가 반환되면 스택 프레임을 제거하는 방식으로 동작합니다. 따라서, 재귀 함수가 많은 중첩 호출을 하게 되면 호출 스택의 크기가 계속 증가하게 되고, 일정 크기 이상으로 깊이가 증가하면 호출 스택이 넘치게 되어 스택 오버플로우(stack overflow) 오류가 발생할 수 있습니다.자바스크립트 엔진마다 호출 스택의 크기 제한은 다를 수 있지만, 대체로 100,000 번 정도의 재귀 호출은 다룰 수 있습니다. 그 이상의 깊이로 재귀 호출을 수행하면 호출 스택 오류가 발생할 수 있으므로 주의해야 합니다. 따라서, 재귀 함수를 사용할 때는 재귀 호출의 깊이를 적절히 조절하고, 필요한 경우 종료 조건을 설정하여 스택 오버플로우 오류를 방지해야 합니다. 또한, 꼬리 재귀 최적화와 같은 최적화 기법을 활용하여 재귀 함수의 깊이 제한을 극복할 수도 있습니다",
        "꼬리 재귀 최적화는 재귀 함수를 반복문과 유사한 형태로 변환하여 스택을 최적화하는 기법입니다. 왼쪽 코드는 일반적인 재귀 함수입니다. 하지만 이 함수는 꼬리 재귀 최적화를 적용할 수 있습니다. 꼬리 위치에 있는 재귀 호출을 반복문으로 변환하여 최적화할 수 있습니다. 오른쪽의 코드에서는 재귀 호출의 꼬리 위치에 해당하는 부분을 반복문처럼 처리합니다. 함수의 두 번째 매개변수인 accumulator를 활용하여 연산의 중간 결과를 누적합니다. 재귀 호출을 하면서 누적된 값을 계속해서 갱신해가며 최종 결과를 반환합니다. 이렇게 꼬리 재귀 최적화를 적용하면 함수가 호출될 때마다 스택에 새로운 프레임이 쌓이지 않고, 현재의 스택 프레임을 재활용하여 메모리 사용을 최적화할 수 있습니다. 이는 재귀 함수의 깊이에 제한을 두지 않고도 스택 오버플로우 오류를 방지할 수 있는 장점을 제공합니다."
    ],
    "getter와 setter": [
        "객체의 프로퍼티는 두가지가 있는데 데이터 프로퍼티와 접근자 프로퍼티가 있습니다. 접근자 프로퍼티는 객체의 속성에 접근하는 방식을 제어하는 특별한 프로퍼티입니다. 접근자 프로퍼티는 getter와 setter 메서드로 구성되어 있습니다. 자바스크립트에서 getter와 setter는 객체의 속성에 접근하고 값을 설정하기 위해서 사용되는 특별한 메소드입니다.",
        "getter는 객체의 속성 값을 가져오는데 사용되며, 속성 이름 앞에 'get' 키워드를 사용하여 정의됩니다. Getter 메서드는 속성에 접근할 때 마다 실행되며, getter 함수의 반환값이 해당 속성의 값으로 사용됩니다. 코드를 보면 user 객체에 firstName과 secondName이라는 두개의 속성을 가지게 하고 fullName은 getter 함수로 정의 하였습니다. 그리고 user 객체의 fullName 접근자 프로퍼티에 접근하여 전체이름을 출력하였습니다. setter는 객체의 속성 값을 설정하는데 사용되며, 속성 이름 앞에 set 키워드를 사용하여 정의됩니다. Setter 메서드는 속성에 값을 할당할 때마다 실행되며, setter 함수의 파라미터로 할당하려는 값이 전달됩니다. 이 코드를 보면 setter 함수도 정의되어 있으며 이 함수는 공백을 기준으로 분리하여 firstName과 secondName에 각각 할당합니다.",
        "접근자 프로퍼티 설명자는 객체의 속성에 대한 메타데이터를 정의하는 객체입니다. 메타데이터는 Object.defineProperty() 메서드를 사용하여 정의됩니다. 접근자 프로퍼티 설명자 객체의 속성에 대해 설명하겠습니다. get은 접근자 프로퍼티의 getter 함수를 정의합니다. set은 접근자 프로퍼티의 setter 함수를 정의합니다. enumerable는 프로퍼티가 열거 가능한지 여부를 나타냅니다. 기본값은 false입니다. configurable는 프로퍼티의 설정 가능 여부를 나타냅니다. 기본값은 false입니다. has는 프로퍼티가 존재하는지 여부를 나타내는 함수입니다. hasOwn는 객체 자체에 프로퍼티가 있는지 여부를 나타내는 함수입니다.deleteProperty는 프로퍼티를 삭제하는 함수입니다. ownKeys는 객체의 모든 프로퍼티 키 배열을 반환하는 함수입니다. 이미지 오른쪽 코드는 접근자 프로퍼티 설명자를 사용할 때 쓰이는 구조를 작성하였습니다."
    ],
    "private protected": [
        "JavaScript에서는 public과 private 라는 두 가지 유형의 객체 필드가 있습니다. public 필드는 어디서든 접근할 수 있으며, 클래스의 외부 인터페이스를 구성하는 데 사용됩니다. 즉, 클래스 인스턴스의 속성으로 외부에서 직접 접근하고 조작할 수 있습니다. private 필드는 클래스 내부에서만 접근할 수 있으며, 내부 인터페이스를 구성하는 데 사용됩니다. 즉, 클래스의 내부 메서드에서만 접근하고 조작할 수 있으며 외부에서 직접 접근할 수 없습니다. 자바스크립트 이외의 언어에서는 protected 필드를 지원하는데, 이는 클래스 자체 및 자손 클래스에서만 접근을 허용합니다. protected 필드는 private 필드와 유사하지만, 자손 클래스에서도 접근이 가능하다는 점이 다릅니다. 자바스크립트는 protected를 직접 지원하지 않지만 이를 모방하여 사용할 수 있습니다.",
        "일반적인 클래스를 예시로 살펴보겠습니다. 이미지 코드는 잘 작동하지만, 길이에 음수를 넣으면 문제가 발생합니다. 예를 들어 -10을 넣으면 넓이가 100이 나오고 둘레가 -40이라는 결과가 나오게 됩니다. 한 변의 길이가 -10인데 둘레가 -40이 되는 것은 이상합니다. 이런 문제를 방지하기 위해 제약을 추가할 수 있습니다.",
        "제약을 추가하여 음수 길이를 가진 경우에 대한 처리를 할 수 있습니다. 아래 코드는 Square 클래스에서 길이(length)가 음수인 경우 에러를 발생시키도록 수정한 예시입니다. 위 코드에서 생성자(constructor)에서 length가 0 이하인 경우에 에러를 발생시킵니다. 따라서 음수를 넣는 경우 에러가 발생하고 객체가 생성되지 않습니다. 이렇게 제약을 추가함으로써 클래스 외부에서 잘못된 값을 사용하는 경우를 방지할 수 있습니다.",
        "그렇지만 클래스 외부에서 음수를 지정하게 되면 잘못된 값을 사용해도 잘 작동하게 됩니다. ",
        "이때 쓰이는게  protected 입니다. 속성 앞에 밑줄을 넣어서 이건 건드리지 말아라 라는 약속으로 접근하지 않게 만들었습니다. 하지만 약속일뿐 자바스크립트에는 protected라는 문법은 없기 때문에 변경이 가능했습니다. 그래서 최근 자바스크립트에서는 아예 접근할 수 없게 하는 메서드 private를 만들었습니다. private 필드는 #기호를 앞에다가 붙이고 클래스 외부에서의 직접적인 접근을 차단합니다. 이를 통해 private 필드는 내부 상태를 보호하고 외부에서의 무분별한 접근을 방지할 수 있습니다. private 필드는 최신 자바스크립트 버전에서 사용가능합니다.",
        "이미지 코드에서 #length는 private 필드로 선언되어 클래스 외부에서의 접근을 차단합니다. 그렇기 때문에, square.#length = -10; 와 같은 코드는 오류를 발생시킵니다. 이를 통해 #length 속성은 클래스 내부에서만 접근 가능하도록 제한됩니다. 따라서, private 필드를 사용함으로써 Square 클래스의 내부 상태를 보호하고 외부에서의 무분별한 접근을 방지할 수 있습니다. 코드 실행 시 음수 값을 할당하려고 하면 오류가 발생하여 잘못된 값을 사용할 수 없도록 합니다. 근데 여기서 중간에 length의 값을 변경하고 싶을 경우가 생깁니다. 이때는 getter와 setter를 이용하는데",
        "이미지 코드에서 setLength 메서드는 외부에서 length 속성을 변경하기 위한 메서드입니다. 이 메서드를 통해 length 속성 값을 변경할 때에도 제약 조건을 검사하여 음수 값을 방지할 수 있습니다. getLength 메서드는 length 속성 값을 가져오는 getter 메서드로, 외부에서 현재 길이를 확인할 수 있습니다. 이를 통해 getter와 setter를 사용하여 클래스 외부에서도 중간에 속성 값을 변경할 수 있도록 제어할 수 있습니다."
    ],
    "제너레이터": [
        "자바스크립트의 제너레이터는 함수의 실행을 중간에 멈췄다가 재개할 수 있는 특별한 함수입니다. 제너레이터 함수는 함수 앞에 별표를 붙여 표시합니다.",
        "제너레이터는 일반 함수와 다릅니다. 일반 함수를 돌리면 함수가 실행되고 반환 값이 나오지만 제너레이터는 함수가 실행을 하지않고, 대신 제너레이터 객체가 반환됩니다.",
        "제너레이터 함수는 함수 내부에  yield 키워드를 사용합니다. yield 키워드는 제너레이터 함수에서 값을 반환하면서 실행을 일시 중단합니다. 함수가 다시 호출될 때 일시 중단된 지점에서 실행을 재개하며, 이전 상태를 유지합니다. 제너레이터 함수를 호출하면 제너레이터 객체가 반환된다고 했는데 함수를 실행하고 싶다면 어떻게 해야될까요? 그럴 떄는 next()메서드를 사용합니다. next()메서드를 호출할 때마다 제너레이터 함수를 실행합니다.",
        "여기서 a.next()를 하면 1이 반환됩니다. 가장 가까운 yield문을 만날 때까지 데이터 객체를 반환했기 떄문에 yield1의 전까지로 값이 1이 반환됩니다. 반환된 데이터 객체는 value와 done 프로퍼티를 가집니다. value는 yield 표현식에서 반환된 값으로 yield 오른쪽 값이고 , done은 제너레이터 함수가 완료되었는지를 나타내는 값입니다. 그러므로 value는 1이 나오고 제너레이터가 아직 끝나지 않았기 때문에 false가 나오게 됩니다. 만약 코드가 끝났다면 done 값이 true가 반환되게 됩니다. 여기서 한번더 next를 해보면 value를 표현할 것이 없으므로 undefined이고 done은 계속 true가 반환되게 됩니다.",
        "제너레이터 객체에는 next 메서드 외에도 return(), throw() 메서드가 있습니다. return()은 제너레이터 함수의 실행을 종료하고 명시적으로 값을 반환합니다. return 메서드를 호출하면 제너레이터 함수의 실행이 종료되며, yield 문 이후의 코드는 실행되지 않습니다. 호출 결과로 반환되는 객체는 value, done 형식으로 next 메서드와 동일하지만 value는 return () 메서드에 전달된 값이고 done은 항상 true입니다. throw는 제너레이터 함수 내에서 예외를 발생시키고 실행을 중단합니다. throw() 메서드는 return 메서드와 동일하게 호출하면 제너레이터 함수의 실행이 중단되고 예외가 발생한 지점 이후의 코드는 실행되지 않습니다. throw 메소드 또한 value done 형식이고 value는 throw 메서드에 전달된 예외 객체입니다. done 또한 항상 true입니다.제너레이터 함수에서 throw() 메서드를 호출하면 제너레이터 함수 외부에서 예외를 처리하는 데 사용될 수 있는 try...catch 블록을 사용할 수 있습니다. 이 메서드들을 어떻게 사용해야되나 하면 next() 메서드를 호출하여 값을 하나씩 생성하거나, return() 메서드를 사용하여 실행을 종료하고 최종 값을 반환하거나, throw() 메서드를 이용하여 예외를 처리할 수 있습니다."
    ],
    "함수": [
        "함수는 프로그램을 구성하는 주요 구성요소 (building block)로 함수를 이용하면 중복 없이 코드를 여러 번 호출 가능합니다",

        "함수 선언 function declaration 방식을 이용하면 함수를 만들 수 있습니다. 함수 선언 방식은 함수 선언문이라고 부르기도 합니다. function 키워드, 함수 이름, 괄호로 둘러싼 매개변수를 차례로 써주면 함수를 선언할 수 있습니다. 각 매개변수를 콤마로 구분해 새롭게 정의한 함수는 함수 이름 옆에 괄호를 붙여 호출할 수 있습니다. 함수의 주요 용도 중 하나는 중복 코드 피하기입니다.",

        "함수 선언 방식 외에 함수 표현식(Function Expression)을 사용해서 함수를 만들 수 있습니다. 함수 선언 방식 외에 함수 표현식(Function Expression)을 사용해서 함수를 만들 수 있습니다.",

        "함수 선언문과 표현식의 차이는 세 가지가 있습니다. 문법, 자바스크립트 엔진이 함수를 생성하는 때, 스코프 입니다. 함수 선언문과 함수 표현식 중 무엇을 선택해야 하나요? 함수 선언문을 이용해 함수를 선언하는걸 먼저 고려하는게 좋습니다. 함수가 선언되기 전에 호출할 수 있어서 코드 구성을 좀 더 자유롭게 할 수 있습니다.",

        "지역 변수는 함수 내에서 선언한 변수입니다. 함수 안에서만 접근 가능합니다. 함수 내부에서 함수 외부의 변수인 외부 변수(outer variable)에 접근할 수 있습니다. 외부 변수는 지역 변수가 없는 경우에만 사용할 수 있습니다. 함수 내부에 외부 변수와 동일한 이름을 가진 변수가 선언되었다면, 내부 변수는 외부 변수를 가립니다 userName 처럼, 함수 외부에 선언된 변수는 전역 변수(global variable) 라고 부릅니다.",

        "매개변수(parameter)를 이용하면 임의의 데이터를 함수 안에 전달할 수 있습니다. 함수 showMessage는 매개변수 from과 text를 가집니다. 함수의 매개변수에 전달된 값을 인수(argument)라고 부르기도 합니다. 매개변수는 함수 선언 방식 괄호 사이에 있는 변수입니다(선언 시 쓰이는 용어). 인수는 함수를 호출할 때 매개변수에 전달되는 값입니다(호출 시 쓰이는 용어). 함수 선언 시 매개변수를 나열하게 되고, 함수를 호출할 땐 인수를 전달해 호출합니다.",

        "함수 호출 시 매개변수에 인수를 전달하지 않으면 그 값은 undefined입니다. 매개변수에 값을 전달하지 않아도 그 값이 undefined 이 되지 않게 하려면 함수를 선언할 때 '='를 사용해 '기본값(default value)'을 설정해주면 됩니다. text가 값을 전달받지 못해도 undefined 대신 기본값 'no text given'이 할당됩니다.",

        "함수를 호출했을 때 함수를 호출한 그곳에 특정 값을 반환하게 할 수 있습니다. 이때 이 특정 값을 반환 값(return value)이라고 부릅니다. 함수를 호출했을 때 함수를 호출한 그곳에 특정 값을 반환하게 할 수 있습니다. 이때 이 특정 값을 반환 값(return value)이라고 부릅니다.",

        "함수를 호출했을 때 함수를 호출한 그곳에 특정 값을 반환하게 할 수 있습니다. 이때 이 특정 값을 반환 값(return value)이라고 부릅니다. 'show'는 시작하는 함수는 대개 무언가를 보여주는 함수입니다. 'get…'은 값을 반환합니다. 'calc…'는 무언가를 계산합니다. 'create…'는 무언가를 생성합니다. 'check…'는 무언가를 확인하고 불린값을 반환합니다.",
        "함수 표현식보다 단순하고 간결한 문법으로 함수를 만들 수 있는 방법이 있습니다. 화살표 함수로 함수 func는 화살표(=>) 우측의 표현식(expression)을 평가하고, 평가 결과를 반환합니다."
    ],
    "객체 복사": [
        "call by sharing은 함수의 인자로 전달되는 값이나 참조는 원본 값 즉 객체를 공유를 하며, 함수 내에서도 이를 변경하게 되면 원본 값 즉 객체도 변경되는 특성을 가집니다. ",

        "해당 예제를 보시면 person 객체를 함수의 인자로 넘기면, 함수 내에서 name 속성을 변경했지만 person.name도 함게 변경된 것을 확인하실 수 있습니다. 이게 바로 call by sharing의 특성으로 함수가 인자로 받은 객체를 공유하게 되기 때문입니다.",

        "하지만 여기서 기본 데이터 타입인 숫자, 문자열, Boolean, null, undefined은 값 자체를 복사해서 전달하기 때문에 함수 내에서 해당 값을 변경해도 원본 값이 변경되지 않습니다. 그래서 이거를 call by value라고 합니다.",

        "예제를 보시면 num 변수를 함수의 인자로 넘기면 함수내에서는 num의 값을 2배로 변경했지만 원본 num 변수 값은 변경되지 않았죠. 함수가 인자로 받은 값을 복사해서 사용하기 때문에 함수 내에서 값을 변경해도 원본 변수 값에서는 영향이 없습니다.",

        "코어 자스 튜토리얼에 나와있는대로 콜 바이 레퍼런스에 대해서 간단히 설명하자면 object와 array 와 같은 참조 데이터 타입에만 해당이 되고 변수에 값이 아닌 주소를 저장하기 때문에 이를 call by reference라고 많이 혼동해서 사용한다고 합니다. 하지만 자바스크립트는 실제로 객체를 그 자체로 전달하는게 아니라,  객체에 대한 참조를 값으로 복사해서 전달하는 것이기에 call by sharing이라고 합니다. 결론적으로는 자바스크립트에서는 call by value와 sharing 두가지를 가지고 있습니다. 객체 Object가 참조에 의해 전달되기 때문에 call by reference로 오인되는 것이며 call by sharingrhk call by reference를 혼합한 형태로 동작합니다.",

        "이게 왜그러냐면 자바스크립에는 객체를 인자로 전달할 때 객체에 대한 참조를 값으로 복사해서 전달하면서도 객체 내의 속성을 변경하면 원본 객체에 반영되는 특성이 있어 call by reference 처럼 동작할 수 있다고 표현하기도 합니다. 자바스크립에서는 변수를 인자로 전달할 때는 실제로는 참조가 복사되는 call by sharing의 특성이 더 강조됩니다.",

        "결국 자바스크립트에는 call by reference가 존재하지 않고 참조 타입 인자도 복사해서 전달하기 때문에 call by value만 존재합니다. 하지만 함수 내부에서 전달된 인자의 수정이 가능하기에 call by value도 call by reference도 아닌 call by sharing 이라는 것을 알 수 있습니다."
    ],
    "배열과 메서드 1": [
        "모두 배열에서 요소들을 조작하거나 검색하는데 사용되는 메서드입니다. 주로 인덱스를 기준으로 작업하는 경우가 많습니다.",

        "splice는 배열에서 요소를 추가, 삭제, 수정합니다. slice도 같은 동작을 하지만 splice와 다른점은 slice는 새로운 배열을 만들기 때문에 원본 배열을 변경하지 않고, splice는 원본 배열을 직접 수정합니다.",

        "함수 문법은 다음과 같습니다. index: 변경을 시작할 인덱스. 음수를 사용할 경우 배열의 끝에서부터 역순으로 카운트합니다.deleteCount: 삭제할 요소의 개수. 생략하면 start 인덱스부터 끝까지의 모든 요소를 삭제합니다. 0 이하의 값을 사용하면 아무것도 삭제하지 않습니다. item1, item2, ...: 배열에 추가할 요소입니다. 생략 가능합니다.",

        "splice 메서드는 삭제한 요소들의 배열을 반환합니다. 만약 요소를 추가하는 경우에는 빈 배열([])을 반환합니다. splice 메서드는 원본 배열을 직접 수정하므로, 실수로 원하지 않는 결과가 나올 수 있습니다. 또한, 인덱스나 삭제할 요소의 개수를 잘못 지정하면 예기치 않은 결과가 발생할 수 있으니 주의해야 합니다.",

        "indexOf는 배열에서 특정 요소의 위치를 찾을 때 사용하는 메서드 입니다. lastIndexOf는 indexOf의 역순이고, includes는 배열에서 특정 요소가 존재하는지의 여부를 확인할 때 사용합니다. indexOf, lastIndexOf는 배열 내에 요소가 없으면 -1를 반환하고 includes는 배열 내에 존재하지 않으면 false를 출력합니다. 간단한 문제를 통해서 indexOf와 lastIndexOf의 메소드를 활용해보겠습니다. 문자열과 검색할 문자가 주어졌을 때, 문자열 안에 검색문자가 몇개나 포함되어 있는지 세는 함수를 작성해보겠습니다. 주어진 문자열은 Hello World 이고 찾을 문자는 O입니다. 여기서 답은 2가 돼야 되겠죠.",

        "우선 첫 번째부터 보시면은 두 개의 매개변수 str과 char를 받습니다. str은 문자열, char는 문자입니다. 먼저 변수 count를 선언하고 초기값을 0으로 설정합니다. 변수 index를 선언하고, str 문자열에서 문자인 char가 처음으로 등장하는 인덱스를 할당합니다. while 반복문을 사용해서 index가 -1 이 아닐 때까지 반복합니다. indexof 메서드는 char가 발견되지 않으면 -1을 반환하기 때문에, index가 -1 이 아니면 char가 발견된 것입니다. 이 경우에 count를 1 증가시키고, indexof 메서드를 다시 호출해서 index가 갱신됩니다. 이때 두번째 인자로 index + 1을 전달해서 다음 인덱스부터 검색하도록 합니다. lastindexoF는 마지막부터 찾기 때문에 검색 위치를 이전 인덱스부터 검색하도록 -1 을 해줍니다",

        "다음은 find와 filter 메소드입니다. find는 주어진 함수의 조건을 만족하는 배열의 첫 번째 요소를 반환하고 filter는 주어진 함수의 조건을 만족하는 모든 요소를 새로운 배열을 반환합니다. find 조건에 맞는 요소가 없다면 undefiend가 반환되고 filter 조건에 맞는 요소가 없다면 빈 배열이 반환됩니다."
    ],
    "map과 set": [
        "Map과 Set은 각각 객체와 배열과 같은 자료구조에서 일부 불필요한 요소를 필터링하거나, 데이터를 쉽게 검색하고 조작할 수 있는 다양한 방법을 제공하는데 사용됩니다. Map은 객체와 비슷한 자료구조이지만, 객체와는 달리 Map은 키(key)와 값(value) 쌍의 형태로 데이터를 저장합니다. 이렇게 데이터를 저장하면 키를 사용하여 해당 값에 빠르게 접근할 수 있습니다. 또한, Map은 키의 중복을 허용하지 않으므로, 중복된 키를 가진 객체와는 달리, 키의 충돌을 방지할 수 있습니다.  서로 다른 형태의 데이터를 연관시켜 저장하고 검색할 때 사용합니다. 예를 들어, 특정 사용자 ID에 해당하는 사용자 정보를 Map에 저장하고, ID를 키로 사용하여 빠르게 검색할 수 있습니다. Set은 중복된 값을 허용하지 않는 자료구조입니다. 따라서, Set을 사용하면 중복된 값이 포함된 배열에서 중복된 값을 제거할 수 있습니다. 이 외에도, Set은 값의 존재 여부를 확인하거나, 교집합, 차집합 등의 집합 연산을 수행하는 데 유용합니다. 중복된 값을 허용하지 않는 자료구조를 사용해야 하는 경우 사용합니다. 예를 들어, 게시판에서 좋아요를 누른 사용자의 ID를 Set에 저장하여 중복 좋아요를 방지할 수 있습니다 Map과 Set 을 사용하여 코드를 작성할 때 더욱 가독성이 높아지고, 코드의 성능을 최적화할 수 있습니다.",

        "성능 면에서 이야기를 해보자면 JavaScript에서 객체와 배열은 Map과 Set과 같은 데이터 구조보다 일반적으로 더 많은 메모리를 사용하며, 더 느린 속도를 가질 수 있습니다. 이는 데이터의 크기와 사용 방법에 따라 다릅니다. Map과 Set의 경우, 각각 객체와 배열로 대체할 수 있지만, 그 경우 코드의 가독성이나 성능 등에 불리한 영향을 줄 수 있습니다. 따라서, Map과 Set은 많은 경우, 더 나은 대안이 될 수 있습니다. Map과 Set은 내부적으로 hash table로 구현되어 있습니다. 각각의 항목을 고유한 키로 식별합니다. 이는 검색, 삽입 및 삭제 연산이 일반적으로 O(1) 시간에 수행될 수 있으며, 데이터가 큰 경우 객체와 배열보다 더 나은 성능을 보일 수 있습니다. 반면에 객체와 배열은 일반적으로 검색, 삽입 및 삭제 연산이 O(n) 시간에 수행되므로, 데이터가 많을수록 성능이 저하됩니다. 하지만, 작은 데이터 세트에서는 객체와 배열이 Map과 Set보다 더 빠를 수 있습니다. 이는 Map과 Set이 추가적인 해싱 및 인덱싱 작업을 수행해야 하기 때문입니다. 따라서, 어떤 데이터 구조를 사용할지 결정하기 위해서는 사용하는 데이터의 크기와 특성, 사용 방법 등을 고려해야 합니다. 따라서, 매우 큰 데이터 세트에서는 Map과 Set이 객체와 배열보다 더 효율적입니다.",

        "Map은 키와 값 쌍을 저장하며, 키는 유일해야 합니다. 즉, 동일한 키를 여러 번 추가할 수 없습니다. Map은 다음과 같은 메서드를 제공합니다. 해당 메서드들을 다 설명하진 않고 뒤에서 예제와 함께 살펴보겠습니다.",

        "첫 줄 부터 보시면 해당 코드는 빈 Map 객체를 생성하고, set() 메서드를 이용하여 키와 값을 쌍으로 추가한 후, get() 메서드로 특정 키에 대응하는 값을 가져와 출력을 합니다. 먼저, const 키워드를 이용하여 변수 myMap을 선언하고, new Map()으로 빈 Map 객체를 생성합니다. 다음으로, myMap.set() 메서드를 사용하여 키(key)와 값(value)을 추가합니다. 이 예제에서는 키로 'key1', 'key2', 'key3'을 각각 추가하고, 값으로 'value1', 'value2', 'value3'을 추가합니다. 그리고나서, myMap.get() 메서드를 이용하여 'key1'에 대응하는 값을 가져와 console.log() 함수를 이용하여 출력합니다. 이 코드에서는 'value1'이 출력됩니다. 그리고나서, myMap.size를 이용하여 Map 객체에 저장된 요소의 개수를 출력합니다. 이 코드에서는 3이 출력됩니다. 마지막으로, myMap.forEach() 메서드를 이용하여 Map 객체의 모든 키-값 쌍을 출력합니다. 이 메서드는 콜백 함수를 인수로 받아, Map 객체에 저장된 모든 키-값 쌍을 콜백 함수에 전달합니다. 콜백 함수에서는 전달된 키와 값에 대해 원하는 작업을 수행할 수 있습니다. 이 예제에서는 콜백 함수에서 ${key} = ${value} 형식의 문자열을 출력하도록 구현했습니다. 따라서, 이 코드는 다음과 같은 결과를 출력합니다.",

        "맵은 다음과 같이 객체를 다룰 때 유용하고 for…of 문과 함께 사용해 Map의 모든 요소에 대해 반복 작업을 수행할 수 있다.",
        "Set은 값의 집합을 저장합니다. 각 값은 유일해야 합니다. 즉, 동일한 값은 여러 번 추가할 수 없습니다. Set은 다음과 같은 메서드를 제공합니다. 이 것 또한 뒤에서 예제와 함께 살펴보시겠습니다",

        "해당 코드는 빈 Set 객체를 생성하고, add() 메서드를 이용하여 값을 추가한 후, has() 메서드로 특정 값을 가지고 있는지 확인하고, forEach() 메서드로 Set 객체의 모든 값을 출력하는 예제입니다. 먼저, const 키워드를 이용하여 변수 mySet을 선언하고, new Set()으로 빈 Set 객체를 생성합니다. 다음으로, mySet.add() 메서드를 사용하여 값을 추가합니다. 이 예제에서는 'value1', 'value2', 'value3'을 각각 추가합니다. 그리고나서, mySet.has() 메서드를 이용하여 'value1'이 Set 객체 내부에 있는지 확인합니다. 이 코드에서는 true가 출력됩니다. 값이 존재하지 않으면 false 출력됩니다. 그리고나서, mySet.size를 이용하여 Set 객체에 저장된 요소의 개수를 출력합니다. 이 코드에서는 3이 출력됩니다. 마지막으로, mySet.forEach() 메서드를 이용하여 Set 객체의 모든 값을 출력합니다. 이 메서드는 콜백 함수를 인수로 받아, Set 객체에 저장된 모든 값을 콜백 함수에 전달합니다. 콜백 함수에서는 전달된 값을 가지고 원하는 작업을 수행할 수 있습니다. 이 예제에서는 콜백 함수에서 value를 그대로 출력하도록 구현했습니다. 따라서, 이 코드는 다음과 같은 결과를 출력합니다.",

        "set은 중복된 값을 제거할 때 유용하고 for…of문과 함께 사용해 set의 모든 요소에 대해 반복 작업을 수행할 수 있습니다."
    ],
    "나머지 매개변수와 스프레드 문법": [
        "나머지 매개변수(rest parameters)는 함수에 전달된 인수들 중에서 마지막 매개변수로 사용되는 점 세 개(...)로 표시됩니다. 나머지 매개변수는 함수 내부에서 가변 인자(variable arguments)를 사용할 수 있게 해줍니다. 나머지 매개변수(rest parameters)는 함수에 전달된 여러 개의 인수를 배열로 받아오는 기능입니다. 이를 이용하면 함수가 몇 개의 인수를 받을지 미리 정하지 않아도 됩니다. 이미지 코드에서는 printArray 함수를 정의하고, 인수를 받아와서 args라는 배열에 저장한 후에 출력합니다. 함수를 호출할 때 전달한 인수들이 args 배열로 전달되고, 콘솔에는 [1, 2, 3, 4, 5]가 출력됩니다. 나머지 매개변수를 사용하면 함수를 호출할 때 전달되는 인수의 개수에 제한이 없습니다. 따라서 유연하게 인수를 다룰 수 있으며, 배열로 받아온 인수들을 반복문 등을 통해 처리할 수 있습니다.",

        "나머지 매개변수는 항상 마지막에 있어야 합니다.",

        "스프레드 문법(spread syntax)은 배열이나 객체를 개별 요소로 확장하거나 복사할 때 사용하는 문법입니다. 이를 통해 배열이나 객체를 쉽게 결합하거나 분해할 수 있습니다. 이미지 코드에서 ...numbers는 스프레드 문법을 사용하여 numbers 배열의 요소들을 개별적인 인수로 확장합니다. console.log() 함수는 개별 인수들을 공백으로 구분하여 출력합니다.",

        "배열을 결합할 때도 스프레드 문법을 사용할 수 있습니다. 위의 코드에서 ...arr1과 ...arr2는 각각 arr1과 arr2 배열의 요소들을 개별적인 요소로 확장합니다. 그리고 확장된 요소들을 새로운 배열 combined에 할당하여 결합합니다. ",

        "스프레드 문법은 객체에서도 사용할 수 있습니다. 객체에서의 스프레드 문법은 객체의 속성들을 다른 객체에 복사하거나, 객체를 새로운 객체로 확장하는 데 사용됩니다. 코드에서 ...obj1과 ...obj2는 각각 obj1과 obj2 객체의 속성들을 개별적인 속성으로 확장합니다. 그리고 확장된 속성들을 새로운 객체 combined에 할당하여 결합합니다. 스프레드 문법을 사용하면 배열이나 객체를 쉽게 다룰 수 있으며, 코드를 간결하게 작성할 수 있습니다.",

        "주어진 두 배열을 결합하고 중복을 제거한 새로운 배열을 반환하는 함수를 작성하세요. 주어진 배열은 arr1과 arr2이며 중복이 제거된 1,2,3,4가 나와야합니다.",

        "코드에서 combineArrays 함수는 두 개의 매개변수 arr1과 arr2를 받아서 두 배열을 결합한 후, 중복을 제거합니다. 먼저 스프레드 문법을 사용하여 arr1과 arr2를 결합하여 combined 배열을 만듭니다. 그리고 combined 배열을 new Set()으로 감싸 중복을 제거한 후, 다시 스프레드 문법을 사용하여 유일한 요소들을 가지는 배열 uniqueArray를 만들어 반환합니다. 이렇게 작성된 함수를 실행하면 result 변수에는 중복이 제거된 새로운 배열이 저장되고, console.log(result)를 통해 해당 배열이 출력됩니다. 이 문제는 스프레드 문법을 활용하여 배열을 결합하고 중복을 제거하는 기본적인 활용 예시입니다"
    ],
    "호출 스케줄링": [
        "setTimeout 함수는 일정 시간이 경과한 후에 콜백 함수를 한 번 실행하는 데 사용됩니다. setTimeout 함수는 다음과 같은 형식으로 사용됩니다. callback은 실행할 함수 또는 실행할 코드 블록입니다. delay는 실행을 지연할 시간(밀리초)입니다.",

        "setTimeout 함수를 사용하여 함수를 일정 시간 후에 실행하는 예제를 살펴보겠습니다. greet 함수를 2초 후에 실행하도록 setTimeout을 설정하였습니다. 따라서 2초 후에 '안녕하세요!'가 콘솔에 출력됩니다.",

        "setInterval 함수는 일정한 시간 간격으로 콜백 함수를 반복해서 실행하는 데 사용됩니다. setInterval 함수는 다음과 같은 형식으로 사용됩니다. callback은 실행할 함수 또는 실행할 코드 블록입니다. delay는 실행 간격(밀리초)입니다.",

        "setInterval 함수를 사용하여 함수를 일정한 간격으로 반복 실행하는 예제를 살펴보겠습니다. 코드에서는 increment 함수를 1초마다 실행하도록 setInterval을 설정하였습니다. 시작 후 1초마다 counter 값을 1씩 증가시키고, 현재 counter 값을 콘솔에 출력합니다. 주의할 점은 setInterval 함수는 명시적으로 멈추기 전까지 계속해서 실행될 수 있으므로, 필요에 따라 clearInterval을 사용하여 중지시켜야 합니다. setTimeout과 setInterval을 사용하여 함수 호출을 스케줄링하면 비동기적인 동작을 구현할 수 있습니다. 타이머 기능을 활용하여 원하는 시간에 함수를 실행하거나 일정한 간격으로 반복 실행하는 등 다양한 상황에서 유용하게 사용됩니다.",

        "setInterval 및 setTimeout을 호출하고 반환된 값을 clearInterval 및 clearTimeout 함수에 전달하여 스케줄링된 작업을 취소할 수 있습니다.",

        "clearTimeout 함수는 이전에 setTimeout으로 설정한 작업을 취소하는 데 사용됩니다. clearTimeout 함수는 다음과 같은 형식으로 사용됩니다. timeoutId는 setTimeout 함수가 반환한 식별자 값입니다. setTimeout 함수를 호출하면 해당 작업은 지정된 시간이 경과한 후에 실행되며, setTimeout은 작업의 식별자 값을 반환합니다. clearTimeout 함수에 이 식별자 값을 전달하여 해당 작업을 취소할 수 있습니다. ",

        "greet 함수를 2초 후에 실행하는 작업을 setTimeout으로 설정하고, 이 작업의 식별자 값을 timeoutId에 저장합니다. setTimeout을 사용하여 1초 후에 clearTimeout을 호출하여 작업을 취소합니다. 따라서 '안녕하세요!'가 출력되기 전에 작업이 취소되므로 콘솔에 아무것도 출력되지 않습니다. setInterval과 setTimeout 함수를 사용하여 작업을 스케줄링하고, 해당 작업을 중지하려면 clearInterval 및 clearTimeout을 사용하면 됩니다. 작업을 중지하는 것은 필요한 경우 스케줄링된 작업의 반복 또는 실행을 중지할 때 유용합니다.",

        "clearInterval 함수는 이전에 setInterval로 설정한 작업을 중지하는 데 사용됩니다. clearInterval 함수는 다음과 같은 형식으로 사용됩니다. intervalId는 setInterval 함수가 반환한 식별자 값입니다. setInterval 함수를 호출하면 해당 작업은 일정한 간격으로 반복 실행되며, setInterval은 작업의 식별자 값을 반환합니다. 이 식별자 값을 clearInterval에 전달하여 해당 작업을 중지할 수 있습니다. increment 함수를 1초마다 실행하는 작업을 setInterval로 설정하고, 이 작업의 식별자 값을 intervalId에 저장합니다. setTimeout을 사용하여 5초 후에 해당 작업을 중지하기 위해 clearInterval에 intervalId를 전달하여 작업을 중지합니다."
    ],
    "프로토타입: 상속": [
        "user, admin, guest 라는 객체를 만들어야한다고 가정해보겠습니다. user의 메서드를 복사하거나 다시 구현하지 않고 user+ 기능을 얹어 admin과 guest를 만들 수 있지 않을까?라는 생각을 하실 겁니다. 사람에 관한 프로퍼티와 메서드를 가진 user라는 객체가 있는데, user와 상당히 유사하지만 약간의 차이가 있는 admin과 guest 객체를 만들어야 한다고 가정해 봅시다. 이때 'user의 메서드를 복사하거나 다시 구현하지 않고 user에 약간의 기능을 얹어 admin과 guest객체를 만들 수 있지 않을까?'라는 생각이 들 겁니다.",
        "자바스크립트 언어의 고유 기능인 프로토타입 상속(prototypal inheritance)을 이용하면 위와 같은 생각을 실현할 수 있습니다.",
        "프로토타입 상속은 자바스크립트에서 객체 지향 프로그래밍에서 상속을 구현하는 방식입니다. 객체는 프로토타입이라고 하는 숨김 프로퍼티를 갖습니다. 프로퍼티는 객체가 가지는 값 또는 특징을 나타내는 데이터 요소입니다. 객체의 상태나 동작을 나타내는 속성입니다. 이 숨김 프로퍼티 값은 null 이거나 다른 객체에 대한 참조가 되는데, 다른 객체를 참조하는 경우 참조 대상을 '프로토타입(prototype)'이라 부릅니다.",
        "object에서 프로퍼티를 읽으려고 하는데 해당 프로퍼티가 없으면 자바스크립트는 자동으로 프로토타입에서 프로퍼티를 찾게 되는데요. 이런 동작 방식을 프로토타입 상속이라 부릅니다. 편리한 기능이나 개발 테크닉 중 프로토타입 상속에 기반해 만들어진 것들이 많습니다.",
        "[[Prototype]]프로퍼티는 내부 프로퍼티이면서 숨김 프로퍼티이지만 다양한 방법을 사용해 개발자가 값을 설정할 수 있습니다.특별한 이름인 __proto__ 을 사용하면 값을 설정할 수 있습니다.",
        "예시로 애니멀과 래빗이라는 객체가 있습니다. 객체 rabbit에서 프로퍼티를 얻고싶은데 해당 프로퍼티가 없다면, 자바스크립트는 자동으로 animal 이라는 객체에서 프로퍼티를 얻습니다. 해당 프로퍼티가 없다는 것은 해당 객체와 그의 프로토타입 체인을 따라 상위 프로토타입 객체에서도 해당 프로퍼티가 존재하지 않는다는 것을 의미합니다. 주어진 코드에서 rabbit 객체는 jumps라는 프로퍼티를 가지고 있습니다. 그러나 rabbit 객체에는 eats라는 프로퍼티가 존재하지 않습니다. 이 경우 자바스크립트는 프로토타입 체인을 따라 animal 객체로 이동하여 해당 프로퍼티를 검색합니다.",
        "(*)로 표시한 줄에선 animal이 rabbit의 프로토타입이 되도록 설정하였습니다.",
        "(**)로 표시한 줄에서 alert 함수가 rabbit.eats 프로퍼티를 읽으려 했는데, rabbit엔 eats라는 프로퍼티가 없습니다. 이때 자바스크립트는 [[Prototype]]이 참조하고 있는 객체인 animal에서 eats를 얻어냅니다. ",
        "이제 'rabbit의 프로토타입은 animal입니다.' 혹은 'rabbit은 animal을 상속받는다.'라고 말 할 수 있게 되었습니다. 프로토타입을 설정해 준 덕분에 rabbit에서도 animal에 구현된 유용한 프로퍼티와 메서드를 사용할 수 있게 되었네요. 이렇게 프로토타입에서 상속받은 프로퍼티를 '상속 프로퍼티(inherited property)'라고 합니다.",
        "메서드 walk는 rabbit의 프로토타입인 animal에서 상속받게 되어서 alert함수에 '동물이 걷습니다' 라고 나오는 것을 볼 수 있습니다.",
        "출력 결과는 true입니다. rabbit 객체에 jumps 속성이 있기 때문에 해당 값을 출력합니다. 출력 결과는 null입니다. delete 연산자는 객체의 속성을 삭제하며, rabbit 객체에서 jumps 속성을 삭제했기 때문에 프로토타입 체인을 따라 animal 객체의 jumps 속성을 찾게 됩니다. animal 객체에는 jumps 속성이 있지만 값이 null로 설정되어 있기 때문에 해당 값을 출력합니다. 출력 결과는 undefined입니다. delete 연산자로 animal 객체의 jumps 속성을 삭제했습니다. 이후 rabbit 객체에서 jumps 속성을 찾을 때, animal 객체에는 해당 속성이 없기 때문에 undefined를 출력합니다.",
        ""
    ],
    "Promise": [
        "promise란 무엇인가? 제주도 여행을 와서 유명한 맛집을 찾아간다고 가정해봅니다. 맛집에 도착했더니 이미 많은 사람들이 줄지어 기다리고 있어 상당히 긴 웨이팅 시간이 예상됩니다. 식당은 손님들의 웨이팅 불편함을 효율적으로 관리하기 위해 알리미어플을 제공합니다. 이제 손님들은 복잡하게 줄을 서서 오랜시간을 기다리지 않아도 됩니다. 이 예시를 한번 코드로 비유해 볼게요.",

        "맛집은 제작코드, 손님은 소비코드, 예약 앱은 프로미스가 되겠습니다.",

        "제작 코드(producing code)는 원격에서 스크립트를 불러오는 것 같은 시간이 걸리는 일을 합니다. 위의 비유에서는 '식당(맛집)'이 제작 코드에 해당합니다.",

        "소비 코드(consuming code)는 '제작 코드'의 결과를 기다렸다가 이를 소비합니다. 이때 소비 주체(함수)는 여럿이 될 수 있다. 위 비유에서 소비 코드는 '손님'입니다.",

        "예약 앱으로 비유되었던 프로미스는 '제작 코드’와 '소비 코드’를 연결해 주는 특별한 자바스크립트 객체입니다. 프로미스는 시간이 얼마나 걸리든 상관없이 약속한 결과를 만들어 내는 '제작 코드’가 준비되었을 때, 모든 소비 코드가 결과를 사용할 수 있도록 해줍니다. 프로미스는 많은 기능이 있고 구조가 훨씬 복잡하지만 이 비유를 이용하여 쉽게 프로미스를 알아보았습니다.",

        "자바스크립트는 비동기 처리를 위해 콜백 패턴을 사용해 왔습니다. 하지만 콜백 패턴은 콜백 헬(callback hell)이라고 불리는 가독성이 떨어지는 코드를 야기하며, 복잡한 비동기 흐름을 다루기 어렵게 만들었습니다. 그래서 이러한 문제의 해결을 위해서 자바스크립트에서 비동기 작업을 처리하는 패턴 중 하나로 , ES6부터 Promise가 도입이 되었습니다. 이후로는 async/await와 함께 많이 사용되고 있습니다. Promise는 비동기적으로 처리되는 작업이 성공적으로 완료되었는지 또는 실패했는지를 나타내는 상태와 그 결과 값을 가지고 있습니다. Promise는 비동기 작업을 좀 더 효율적이고 직관적으로 다룰 수 있게 해주는 추상화 계층입니다. 콜백 패턴에 비해 가독성을 높이고, 비동기 코드의 제어 흐름을 명확하게 표현할 수 있습니다.",

        "Promise 객체는 세 가지 상태를 가질 수 있습니다. 첫번째는 대기 상태로 비동기 작업이 아직 완료되지 않은 초기 상태입니다. 두번째는 이행상태로 비동기 작업이 성공적으로 완료된 상태입니다. 세번째는 거부상태로 비동기 작업이 실패한 상태입니다. 뒤에서 자세히 살펴보겠습니다",

        "대기(pending)상태는 Promise 객체가 생성된 초기 상태입니다. 비동기 작업이 아직 완료되지 않았으므로, 이행 또는 거부 상태로 전환되지 않았습니다. 대기 상태에서는 아무런 동작도 수행하지 않습니다.",
        "이행(fulfilled)상태는 비동기 작업이 성공적으로 완료되어 결과 값을 반환한 상태입니다. Promise 객체가 이행 상태로 전환되면, 더 이상 다른 상태로 전환되지 않습니다. 이행 상태에서는 이행된 결과 값을 가지고 있으며, 이행된 Promise는 then 메서드를 통해 처리될 수 있습니다.",

        "거부(rejected) 상태는 비동기 작업이 실패하여 오류가 발생한 상태입니다. Promise 객체가 거부 상태로 전환되면, 더 이상 다른 상태로 전환되지 않습니다. 거부 상태에서는 실패한 이유를 나타내는 에러 정보를 가지고 있으며, 거부된 Promise는 catch 메서드를 통해 처리될 수 있습니다. 이런 Promise의 상태 변화는 비동기 작업의 성공 또는 실패에 따라 결정됩니다. 바로 뒷장에서 코드와 함께 살펴보겠습니다.",

        "Promise는 비동기 작업을 처리하기 위해 new Promise() 를 사용하여 생성합니다. new Promise 에 전달되는 함수를 executor 이라고 합니다. new Promise에 전달되는 함수는 executor(실행자, 실행 함수)라고 부릅니다. executor는 new Promise가 만들어질 때 자동으로 실행되는데, 결과를 최종적으로 만들어내는 제작 코드를 포함합니다. 위 비유에서 '맛집'이 바로 executor이다. 저희가 아까 1장에본 제작코드, 즉 맛집입니다.",

        "Promise 생성자 함수는 resolve와 reject라는 두 개의 콜백 함수를 매개변수로 받습니다. resolve 함수는 비동기 작업이 성공적으로 완료되었을 때 호출되며, reject 함수는 비동기 작업이 실패했을 때 호출됩니다.",
        "Promise는 비동기 작업의 상태와 결과를 추적하고, 작업이 완료되면 해당 결과를 사용자가 지정한 콜백 함수에 전달합니다. 이를 통해 비동기 작업의 결과를 처리하고, 다음 작업을 연결하거나 에러를 처리할 수 있습니다. 지금까지 executor 제작 코드, 즉 맛집을 알아봤다면 지금은 만들어진 제작 코드의 결과를 기다렸다가 이를 소비하는 소비코드에 대해서 알아보겠습니다. Promise 객체는 then, catch, finally 등의 메서드를 제공하여 비동기 작업의 결과를 처리할 수 있습니다. then 메서드는 Promise가 이행된 경우에 호출되며, 첫 번째 매개변수로 이행된 결과 값을 받습니다. catch 메서드는 Promise가 거부된 경우에 호출되며, 첫 번째 매개변수로 거부된 이유를 받습니다. finally 메서드는 Promise가 이행되거나 거부된 이후에 항상 호출됩니다. 다음장에서 자세히 알아보도록 하겠습니다.",

        "then 메서드 이행 상태(fulfilled)인 Promise에 대한 처리를 정의합니다. 이행된 결과 값을 받아 처리하는 콜백 함수를 등록할 수 있습니다. then 메서드는 Promise가 이행된 경우에 호출됩니다. then은 프로미스가 정상적으로 잘 수행이 되어서 마지막에 최종적으로 resolve라는 콜백 함수를 통해서 전달한 값이 value의 파라미터로 전달되어서 들어오는 걸 볼 수 있습니다.",

        "반대로 reject 를 사용했을 때에는  다음과 같은 에러 메세지가 출력됩니다. Uncaught라는 에러가 발생한다 이 말은  then이라는 것을 이용해서 성공적인 케이스만 다뤘기 때문에 잡히지 않은 에러가 발생한 것입니다.",

        "catch 메서드 방금 전과 같은 에러가 발생한 경우 catch 라는 메서드를 사용해서 에러를 잡을 수 있는데요. 이제는 더 이상 에러가 발생하지 않고 받아온 에러가 콘솔 창에 실행되는 것을 확인할 수 있습니다.",

        "finally 메서드는 finally 는 성공이든 실패이든 상관없이 무조건 마지막에 호출되는 메서드입니다. 위와 같이 성공,실패 여부와 관계없이 어떤 기능을 마지막으로 수행하고 싶을 때 사용합니다.",

        "프로미스는 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용합니다. 일반적으로 웹 애플리케이션을 구현할 때 서버에서 데이터를 요청하고 받아오기 위해서 입니다. 즉, 데이터를 모두 받아오기도 전에, 다 받아온것마냥 화면에 데이터를 표시하려고 하면 오류가 발생하거나, 빈 화면이 뜨는 것입니다.",

        "Promise는 생성된 시점에서 알려지지 않은 값을 대신합니다. '값이 없을 때 얘가 대신할거고! 값이 나오면 걔를 반환할게~'라고 생각하시면 됩니다. 자바스크립트 Promise는 비동기 처리를 위한 강력한 도구입니다. 콜백 헬과 같은 코드 구조를 피하고 가독성을 높이며, 비동기 작업의 결과를 효율적으로 처리할 수 있습니다. async/await와 함께 사용하면 더욱 간결하고 직관적인 코드를 작성할 수 있습니다. Promise를 잘 활용하여 비동기 작업을 효율적으로 다루어 개발 생산성을 높이는데 도움이 될 것입니다."
    ],
    "Promise와 에러 핸들링": [
        "프라미스는 비동기 작업이 완료되었을 때 결과를 나타내는데, 성공적인 경우(resolve)와 실패한 경우(reject)로 나뉩니다.  예외 처리는 주로 실패한 경우인 'reject'를 통해 비동기 작업의 실패를 나타내는 역할을 합니다. 에러 핸들링은 프라미스에서 발생할 수 있는 예외 상황을 처리하는 방법을 의미합니다.",

        "만약에 여러분들이 짠 코드가 비동기 작업을 실패했을 때 예를 들어 네트워크 요청이 실패하거나 파일을 찾을 수 없는 경우, 프라미스는 실패 상태로 전환됩니다. 이때 에러 핸들링을 통해 실패 상태를 적절히 처리할 수 있습니다.",

        "에러핸들링은 예외상황 ~ 를 통해서 처리할 수 있습니다. 예외 상황 처리는 에러 핸들링을 통해 비동기 작업 중 발생하는 예외 상황에 대응할 수 있습니다. 이를 통해 애플리케이션의 안정성을 높일 수 있습니다. 오류 메시지 표시는 사용자에게 적절한 오류 메시지를 표시하여 오류를 이해하고 대응할 수 있도록 도움을 줄 수 있습니다. 대체 동작 수행는 에러 핸들링을 통해 작업 실패 시 대체 동작을 수행할 수 있습니다. 예를 들어 네트워크 요청이 실패하면 기본값을 반환하거나 대체 데이터를 사용할 수 있습니다. 에러 로깅은 에러 핸들링을 통해 발생한 에러를 로깅하여 디버깅이나 모니터링에 활용할 수 있습니다.",

        "보통 이 4가지들은 각자 사용해도 되는데 보통은 다 같이 사용이 된다고 합니다.",

        "에러 핸들링은 코드의 가독성과 유지보수를 위해 매우 중요한 부분입니다. 적절한 에러 핸들링을 통해 예외 상황에 대비하고, 사용자에게 적절한 오류 메시지를 표시하거나 대체 동작을 수행할 수 있습니다.",

        "존재하지 않는 주소를 fetch에 넘겨주는 예시를 살펴봅시다. .catch에서 에러를 잡게됩니다.",

        "다음과 같이 오류 알림창이 뜨게 되겠죠",

        "프라미스 executor와 프라미스 핸들러 코드 주위엔 '보이지 않는(암시적) try..catch가 있습니다. 예외가 발생하면 암시적 try..catch에서 예외를 잡고 이를 reject처럼 다룹니다.",

        "위 예시는 아래 예시와 똑같이 동작합니다. executor 주위의 '암시적 try..catch'는 스스로 에러를 잡고,",

        "에러를 거부상태의 프라미스로 변경시킵니다.",

        "메서드 체인 마지막의 .catch는 try..catch`와 유사한 역할을 합니다. .then핸들러를 원하는 만큼 사용하다 마지막에 .catch 하나만 붙이면 .then 핸들러에서 발생한 모든 에러를 처리할 수 있습니다.",

        "일반 try..catch에선 에러를 분석하고, 처리할 수 없는 에러라 판단되면 에러를 다시 던질 때가 있습니다. 프라미스에도 유사한 일을 할 수 있습니다. .catch를 활용한 또 다른 사례를 살펴봅시다. (*)로 표시한 핸들러에서 에러를 잡는데, 여기서는 에러를 처리하지 못하기 때문에(URIError 처리 방법만 알고 있음) 에러를 다시 던집니다.",

        "에러를 처리하지 못하면 무슨 일이 생길까요? 아래 예시처럼 체인 끝에 .catch를 추가하지 못하는 경우처럼 말이죠. 에러가 발생하면 프라미스는 거부상태가 되고, 실행 흐름은 가장 가까운 rejection 핸들러로 넘어갑니다. 그런데 위 예시엔 예외를 처리해 줄 핸들러가 없어서 에러가 '갇혀버립니다'. 에러를 처리할 코드가 없기 때문입니다. 이런 식으로 코드에 처리하지 못한 에러가 남게 되면 실무에선 끔찍한 일이 발생합니다. 일반적인 에러가 발생하고 이를 try..catch에서 처리하지 못하는 경우를 생각해봅시다. 스크립트가 죽고 콘솔 창에 메시지가 출력되겠죠. 거부된 프라미스를 처리하지 못했을 때도 유사한 일이 발생합니다.",

        " 자바스크립트 엔진은 프라미스 거부를 추적하다가 위와 같은 상황이 발생하면 전역 에러를 생성합니다. 콘솔창을 열고 위 예시를 실행하면 전역 에러를 확인할 수 있습니다.브라우저 환경에선 이런 에러를 unhandledrejection 이벤트로 처리할 수 있습니다. 브라우저 환경에선 에러가 발생했는데 .catch가 없으면 unhandledrejection 핸들러가 트리거 됩니다. unhandledrejection 핸들러는 에러 정보가 담긴 event 객체를 받기 때문에 이 핸들러 안에서 원하는 작업을 할 수 있습니다. 대개 이런 에러는 회복할 수 없기 때문에 개발자로서 할 수 있는 최선의 방법은 사용자에게 문제 상황을 알리고 가능하다면 서버에 에러 정보를 보내는 것입니다."
    ]
}
